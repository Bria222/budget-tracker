{"version":3,"sources":["services/storage/FirestoreApi.ts"],"names":["FirestoreApi","userId","enablePersistence","db","Error","this","firebase","firestore","error","console","warn","object","id","undefined","budgetId","budgetsCol","doc","expenseId","expensesCol","categoryId","categoriesCol","budget","timestamp","_saveBudget","deleted","removeUndefined","getBudgetDoc","identifier","set","setLastTimeSaved","deleteEntity","get","data","where","orderBy","querySnapshot","budgets","forEach","getExpenseDoc","expense","_getExpenses","queryBuilder","expenses","batch","Object","values","commit","category","categories","getCategoryDoc","entries","k","userDoc","Date","now","documentRef","runTransaction","transaction","a","entity","lastTimeSaved","promises","importExpenses","map","b","Promise","all","writes","batches","push","getBudgets","getCategories","getLastTimeSaved","collection"],"mappings":"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","file":"static/js/34.13b5a5df.chunk.js","sourcesContent":["import { Budget, BudgetsMap, ExpensesMap, Expense, CategoriesMap, Category, User, ExportDataSet } from '../../api';\nimport firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport { SubStorageApi, DbItem } from './StorageApi';\n\ninterface ExpenseDb extends Expense, DbItem { }\ninterface BudgetDb extends Budget, DbItem { }\ninterface CategoryDb extends Category, DbItem { }\n\nexport class FirestoreApi implements SubStorageApi {\n    \n    private readonly db: firebase.firestore.Firestore;\n    private readonly userId: string;\n\n    constructor(userId: string, enablePersistence: boolean) {\n        if (userId) {\n            this.userId = userId;\n            this.db = firebase.firestore();\n            if (enablePersistence) {\n                this.enablePersistence();\n            }\n        } else {\n            throw Error('User must be logged in to be able to use firestore');\n        }\n    }\n\n    private enablePersistence () {\n        try {\n            this.db.enablePersistence();    \n        } catch (error) {\n            console.warn('Persistence is already enabled: ', error);\n        }\n    }\n\n    // Firestore throws an error while saving fields with undefined values\n    private removeUndefined <T>(object: T) {\n        for (const id in object) {\n            if (object[id] === undefined) {\n                delete object[id];\n            }\n        }\n        return object;\n    }\n\n    get userDoc () {\n        return this.db.collection('users').doc(this.userId);\n    }\n\n    get budgetsCol() {\n        return this.userDoc.collection('budgets');\n    }\n\n    getBudgetDoc (budgetId: string) {\n        return this.budgetsCol.doc(budgetId);\n    }\n\n    get expensesCol() {\n        return this.userDoc.collection('expenses');\n    }\n\n    getExpenseDoc (expenseId: string) {\n        return this.expensesCol.doc(expenseId);\n    }\n\n    get categoriesCol () {\n        return this.userDoc.collection('categories');\n    }\n\n    getCategoryDoc(categoryId: string) {\n        return this.categoriesCol.doc(categoryId);\n    }\n\n    async setBudget(budget: Budget, timestamp: number) {\n        return this._saveBudget({deleted: 0, ...budget, timestamp});\n    }\n\n    private async _saveBudget(budget: BudgetDb) {\n        this.removeUndefined(budget);\n        await this.getBudgetDoc(budget.identifier).set(budget);\n        return this.setLastTimeSaved(budget.timestamp);\n    } \n\n    async deleteBudget(budgetId: string, timestamp: number) {\n        return this.deleteEntity(this.getBudgetDoc(budgetId), timestamp);\n    }\n\n    async getBudget (id: string) {\n        try {\n            const doc = await this.getBudgetDoc(id).get();\n            return doc.data() as Budget;\n        } catch (error) {\n            console.warn(`Error getting budget ${id}: `, error);\n            return undefined;\n        }\n    }\n\n    async getBudgets (timestamp = 0): Promise<BudgetsMap> {\n        const querySnapshot = await this.budgetsCol\n            .where('deleted', '==',  0)\n            .orderBy('timestamp', 'desc')\n            .where('timestamp', '>', timestamp)\n            .get();\n        const budgets: BudgetsMap = {};\n        querySnapshot.forEach((doc) => {\n            budgets[doc.id] = doc.data() as Budget;\n        });\n        return budgets;\n    }\n\n    async getExpense(expenseId: string) {\n        const expense = await this.getExpenseDoc(expenseId).get();\n        return expense.data() as Expense;\n    }\n    \n    async getExpenses(budgetId: string, timestamp = 0): Promise<ExpensesMap> {\n        return this._getExpenses(budgetId, timestamp);\n    }\n\n    async _getExpenses(budgetId?: string, timestamp = 0): Promise<ExpensesMap> {\n        let queryBuilder = await this.expensesCol.where('deleted', '==',  0);\n        if (budgetId) {\n            queryBuilder = queryBuilder.where('budgetId', '==', budgetId);\n        }\n        if (timestamp) {\n            queryBuilder = queryBuilder.orderBy('timestamp').where('timestamp', '>', timestamp);\n        }\n        const querySnapshot = await queryBuilder.orderBy('when', 'desc').get();\n\n        const expenses: ExpensesMap = {};\n        querySnapshot.forEach((doc) => {\n            expenses[doc.id] = doc.data() as Expense;\n        });\n        return expenses;\n    }\n\n    async setExpenses(expenses: Expense[], timestamp: number) {\n        const batch = this.db.batch();\n        Object\n            .values(expenses)\n            .forEach(expense => batch.set(\n                this.getExpenseDoc(expense.identifier), \n                this.removeUndefined({deleted: 0, ...expense, timestamp})));\n        this.setLastTimeSaved(timestamp, batch);\n        return batch.commit();\n    }\n\n    async deleteExpense(expenseId: string, timestamp: number) {\n        return this.deleteEntity(this.getExpenseDoc(expenseId), timestamp);\n    }\n\n    async getCategory(identifier: string) {\n        const category = await this.getExpenseDoc(identifier).get();\n        return category.data() as Category;\n    }\n\n    async getCategories(timestamp = 0): Promise<CategoriesMap> {\n        const querySnapshot = await this.categoriesCol\n            .where('deleted', '==',  0)\n            .orderBy('timestamp')\n            .where('timestamp', '>', timestamp)\n            .orderBy('name').get();\n        const categories: CategoriesMap = {};\n        querySnapshot.forEach((doc) => {\n            categories[doc.id] = doc.data() as Category;\n        });\n        return categories;    \n    }\n\n    async setCategories(categories: CategoryDb[], timestamp: number){\n        const batch = this.db.batch();\n        Object\n            .values(categories)\n            .forEach(category => batch.set(\n                this.getCategoryDoc(category.identifier), \n                this.removeUndefined({deleted: 0, ...category, timestamp})));\n        this.setLastTimeSaved(timestamp, batch);\n        return batch.commit();\n    }\n\n    async saveCategories(categories: CategoriesMap, timestamp: number){\n        const batch = this.db.batch();\n        Object\n            .entries(categories)\n            .forEach(([k, category]) => batch.set(\n                this.categoriesCol.doc(k), \n                this.removeUndefined({deleted: 0, ...category, timestamp})));\n        await batch.commit();\n        return this.setLastTimeSaved(timestamp);\n    }\n\n    async deleteCategory(categoryId: string, timestamp: number){\n        return this.deleteEntity(this.getCategoryDoc(categoryId), timestamp);\n    }\n\n    async getLastTimeSaved () {\n        try {\n            return ((await this.userDoc.get()).data() as User).timestamp || 0;\n        } catch (error) {\n            console.warn('Cannot retrieve timestamp from firebase');\n            return 0;\n        }\n    }\n\n    async setLastTimeSaved (timestamp=Date.now() , batch?: firebase.firestore.WriteBatch) {\n        if (batch) {\n            batch.set(this.userDoc, {timestamp});\n        } else {\n            return this.userDoc.set({timestamp});\n        }\n    }\n\n    private async deleteEntity (documentRef: firebase.firestore.DocumentReference, timestamp: number) {\n        const deleted = await this.db.runTransaction(async function (transaction) {\n            const entity = (await transaction.get(documentRef)).data() as DbItem;\n            if (entity) {\n                await transaction.set(documentRef, {...entity, deleted: 1, timestamp});\n                return true;\n            }\n            return false;\n        });\n        if (deleted) {\n            return this.setLastTimeSaved(timestamp);    \n        }\n    }\n\n    async import(data: ExportDataSet) {\n        const {budgets, expenses, categories, lastTimeSaved} = data;\n        const batch = this.db.batch();\n        Object\n            .values(categories)\n            .forEach(category => batch.set(\n                this.getCategoryDoc(category.identifier), \n                this.removeUndefined({timestamp: lastTimeSaved, ...category})));\n        Object\n            .values(budgets)\n            .forEach(budget => batch.set(\n                this.getBudgetDoc(budget.identifier), \n                this.removeUndefined({timestamp: lastTimeSaved, ...budget})));\n        batch.set(this.userDoc, {timestamp: lastTimeSaved});\n                \n        const promises = [\n            batch, \n            ...this.importExpenses(Object.values(expenses), lastTimeSaved)\n        ].map(b => b.commit());\n        \n        await Promise.all(promises);\n    }\n\n    private importExpenses (expenses: Expense[], timestamp: number) {\n        let batch = this.db.batch();\n        let writes = 0;\n        const batches: firebase.firestore.WriteBatch[] = [batch,];\n        for (const expense of expenses) {\n            // split in chunks due to firestore limitation of 500 writes per request\n            if (writes === 499) {\n                batch = this.db.batch();\n                batches.push(batch);\n                writes = 0;\n            }\n            batch.set(\n                this.getExpenseDoc(expense.identifier), \n                this.removeUndefined({timestamp, ...expense}));\n            writes ++;\n        }\n        return batches;\n    }\n\n    async export(): Promise<ExportDataSet> {\n        const [budgets, categories, expenses, lastTimeSaved] = await Promise.all(\n            [\n                this.getBudgets(), \n                this.getCategories(), \n                this._getExpenses(),\n                this.getLastTimeSaved()]);\n\n        return {budgets, expenses, categories, lastTimeSaved};\n    }\n}\n"],"sourceRoot":""}