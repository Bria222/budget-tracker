{"version":3,"sources":["domain/DateDay.ts","domain/date.ts","domain/NestedTotal.ts","domain/utils/applyRate.ts","domain/ExpenseModel.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","domain/ExpensesYearMap.ts","domain/BudgetModelImpl.ts","domain/stores/BudgetsStoreImpl.ts"],"names":["DateDay","date","Date","_date","this","getFullYear","getMonth","getDate","days","setDate","months","setMonth","years","setFullYear","getTime","isToday","Intl","DateTimeFormat","undefined","day","month","year","format","timestampMs","now","DAY_MS","dateDiff","from","to","Math","floor","getISODateString","toISOString","slice","monthToString","monthYearToString","NestedTotal","_total","_subTotals","n","subTotalIndexes","subTotal","_getSubTotal","add","index","shift","indexes","getSubtotal","total","getAverage","avg","Object","keys","length","applyRate","amount","rate","ExpenseModel","info","amountBaseCurrency","currency","categoryId","countryCode","description","identifier","when","budgetId","splitInDays","validate","budget","fromMs","toMs","totals","split","em","dateParts","subtract","fieldErrors","push","Error","join","expenses","i","fromTimeMs","addDays","timeMs","JSON","stringify","values","map","e","reduce","a","b","Parent","args","Class","Reflect","construct","sham","Proxy","prototype","toString","call","isNativeReflectConstruct","apply","instance","Function","bind","setPrototypeOf","arguments","_cache","Map","fn","indexOf","TypeError","has","get","set","Wrapper","getPrototypeOf","constructor","create","value","enumerable","writable","configurable","ExpensesYearMap","expense","ExpensesMonthMap","addExpense","deleteExpense","size","delete","ExpensesDayMap","m","addDailyExpensesByDate","dayExpenses","getExpenses","addExpensesByDate","inputDays","output","d","input","expensesMap","BudgetModelImpl","_info","_expenses","_expenseGroups","_nestedTotalExpenses","_days","_totalDays","nestedTotalExpenses","expenseGroups","getAllGroupedByDate","newExpense","oldExpense","_subtractTotal","_addToTotal","oldExpenses","oe","_updateTotalExpenses","ne","expenseId","rates","newTotals","_getBaseAmount","addToTotals","inBudgetDates","subtractTotal","_updateExpensesBaseAmount","name","Promise","resolve","categories","forEach","id","budgets","lastTimeSaved","daysUntilToday","totalExpenses","round","totalDays","eg","splitExpense","base","BudgetsStoreImpl","app","_budgetModels","_app","_storage","storage","addObserver","clear","getBudgets","bm","getBudget","budgetModel","getCurrenciesStore","getRates","setBudget","getBudgetModel","model","setExpense","setExpenses","getExpense","deleteBudget","all","data","fixedCategories","entries","setBudgets","setExpensesList","getCategoriesStore","setCategories","getCategories","getBudgetsIndex"],"mappings":"+KAEaA,EAAb,WAGI,aAAgC,IAApBC,EAAmB,uDAAZ,IAAIC,KAAQ,yBAFdC,WAEc,EAC3BC,KAAKD,MAAQ,IAAID,KACbD,EAAKI,cACLJ,EAAKK,WACLL,EAAKM,WAPjB,oDAWQ,OAAO,IAAIP,EAAQI,KAAKD,SAXhC,8BA6CaK,GAEL,OADAJ,KAAKD,MAAMM,QAAQL,KAAKD,MAAMI,UAAYC,GACnCJ,OA/Cf,gCAqDeM,GAEP,OADAN,KAAKD,MAAMQ,SAASP,KAAKD,MAAMG,WAAaI,GACrCN,OAvDf,+BA6DcQ,GAEN,OADAR,KAAKD,MAAMU,YAAYT,KAAKD,MAAME,cAAgBO,GAC3CR,OA/Df,6BAgFWH,GACH,OAAOG,KAAKD,MAAMW,YAAcb,EAAKE,MAAMW,YAjFnD,2BAeQ,OAAOV,KAAKD,MAAME,gBAf1B,4BAmBQ,OAAOD,KAAKD,MAAMG,aAnB1B,0BAuBQ,OAAOF,KAAKD,MAAMI,YAvB1B,6BAmCQ,OAAOH,KAAKD,MAAMW,YAnC1B,8BAuCQ,OAAOd,EAAQe,QAAQX,QAvC/B,kCA6EQ,OAHW,IAAIY,KAAKC,oBAChBC,EACA,CAACC,IAAK,UAAWC,MAAO,OAAQC,KAAM,YAChCC,OAAOlB,KAAKD,UA7E9B,kCA0BuBoB,GACf,OAAO,IAAIvB,EAAQ,IAAIE,KAAKqB,MA3BpC,8BA8BoBtB,GACZ,OAAO,IAAID,EAAQ,IAAIE,KAAKD,EAAKoB,KAAMpB,EAAKmB,MAAOnB,EAAKkB,QA/BhE,8BAkEmBlB,GACX,IAAMuB,EAAM,IAAItB,KAChB,OAAOD,EAAKkB,MAAQK,EAAIjB,WACpBN,EAAKmB,QAAUI,EAAIlB,YACnBL,EAAKoB,OAASG,EAAInB,kBAtE9B,M,iCCDA,4IAAMoB,EAAS,MAOR,SAASC,EAASC,EAAcC,GACnC,OAAOC,KAAKC,OAAOF,EAAKD,GAAMF,GAAU,EAMrC,SAASM,IACZ,OADiD,uDAAZ,IAAI7B,MAC7B8B,cAAcC,MAAM,EAAE,IAM/B,SAASC,EAAed,GAE3B,OADW,IAAIJ,KAAKC,oBAAeC,EAAW,CAACE,MAAO,SAC5CE,OAAO,IAAIpB,KAAK,IAAMkB,EAAO,IAMpC,SAASe,EAAmBd,EAAcD,GAE7C,OADW,IAAIJ,KAAKC,oBAAeC,EAAW,CAACE,MAAO,OAAQC,KAAM,YAC1DC,OAAO,IAAIpB,KAAKmB,EAAMD,EAAO,M,uFC5B9BgB,EAAb,WAII,aAAc,yBAHNC,YAGK,OAFLC,gBAEK,EACTlC,KAAKiC,OAAS,EACdjC,KAAKkC,WAAa,GAN1B,gDASQC,EAAWC,GACXpC,KAAKiC,QAAUE,EACf,IAAME,EAAWrC,KAAKsC,aAAaF,GAEnC,OADAC,GAAYA,EAASE,IAAIJ,EAAGC,GACrBpC,KAAKiC,SAbpB,+BAgBaE,EAAWC,GAChB,OAAOpC,KAAKuC,KAAKJ,EAAGC,KAjB5B,mCAoByBA,GACjB,QAAwBtB,IAApBsB,EAA+B,CAC/B,IAAMI,EAAQJ,EAAgBK,QAC9B,QAAc3B,IAAV0B,EAIA,OAHMA,KAASxC,KAAKkC,aAChBlC,KAAKkC,WAAWM,GAAS,IAAIR,GAE1BhC,KAAKkC,WAAWM,MA3BvC,kCAyCgBE,GACR,IAAMF,EAAQE,EAAQD,QACtB,YAAc3B,IAAV0B,EACIA,KAASxC,KAAKkC,WACPlC,KAAKkC,WAAWM,GAAOG,YAAYD,GAEnC,EAGR1C,KAAK4C,QAlDpB,iCAqDeF,GACP,IAAMF,EAAQE,EAAQD,QACtB,YAAc3B,IAAV0B,EACIA,KAASxC,KAAKkC,WACPlC,KAAKkC,WAAWM,GAAOK,WAAWH,GAElC,EAGR1C,KAAK8C,MA9DpB,4BAkCQ,OAAO9C,KAAKiC,SAlCpB,0BAsCQ,OAAOjC,KAAKiC,OAASc,OAAOC,KAAKhD,KAAKkC,YAAYe,SAtC1D,8BAkEQ,OAAOF,OAAOC,KAAKhD,KAAKkC,gBAlEhC,M,iCCHe,SAASgB,EAAWC,EAAgBC,GAC/C,OAAOD,EAASC,EADpB,mC,iqBCGO,IAAMC,EAAb,WAcI,WAAaC,GAAgB,yBAZrBvD,WAYoB,OAXnBoD,YAWmB,OAV5BI,wBAU4B,OATnBC,cASmB,OARnBC,gBAQmB,OAPnBC,iBAOmB,OANnBC,iBAMmB,OALnBC,gBAKmB,OAJnBC,UAImB,OAHnBC,cAGmB,OAFnBC,iBAEmB,EACxB/D,KAAK4D,WAAaN,EAAKM,WACvB5D,KAAKuD,mBAAqBD,EAAKC,mBAC/BvD,KAAKmD,OAASG,EAAKH,OACnBnD,KAAKwD,SAAWF,EAAKE,SACrBxD,KAAKyD,WAAaH,EAAKG,WACvBzD,KAAK0D,YAAcJ,EAAKI,YACxB1D,KAAK2D,YAAcL,EAAKK,YACxB3D,KAAK6D,KAAOP,EAAKO,KACjB7D,KAAK8D,SAAWR,EAAKQ,SACrB9D,KAAK+D,YAAcT,EAAKS,YAAc,EAAIT,EAAKS,YAAc,EAC7D/D,KAAKgE,WAzBb,0DAkEmBC,GACX,OAAOjE,KAAK6D,MAAQI,EAAOzC,IAAMxB,KAAK6D,MAAQI,EAAO1C,OAnE7D,8BAsEa2C,EAAgBC,GACrB,OAAOnE,KAAK6D,MAAQM,GAAQnE,KAAK6D,MAAQK,IAvEjD,kCA0EgBE,GAAsB,IAAD,uBAC7B,YAAiBpE,KAAKqE,QAAtB,+CAA+B,CAAC,IAArBC,EAAoB,QAC3BF,EAAO7B,IAAI+B,EAAGf,mBAAoBe,EAAGC,YAFZ,qFA1ErC,oCAgFkBH,GAAsB,IAAD,uBAC/B,YAAiBpE,KAAKqE,QAAtB,+CAA+B,CAAC,IAArBC,EAAoB,QAC3BF,EAAOI,SAASF,EAAGf,mBAAoBe,EAAGC,YAFf,qFAhFvC,iCAuFQ,IAAME,EAAc,GAapB,QAZsB3D,IAAlBd,KAAK8D,UACLW,EAAYC,KAAK,0BAEW5D,IAA5Bd,KAAKuD,oBACLkB,EAAYC,KAAK,2BAEW,IAA5B1E,KAAK0D,YAAYT,QACjBwB,EAAYC,KAAK,gBAEQ,IAAzB1E,KAAKwD,SAASP,QACdwB,EAAYC,KAAK,iBAEjBD,EAAYxB,OAAS,EACrB,MAAM0B,MAAM,oBAAD,OAAqB3E,KAAK4D,WAA1B,qBAAiDa,EAAYG,KAAK,UArGzF,8BA6GQ,GAAI5E,KAAK+D,YAAc,EACnB,MAAMY,MAAM,sDACT,GAAyB,IAArB3E,KAAK+D,YACZ,MAAO,CAAC/D,MAKR,IAHA,IAAMuD,EAAsBvD,KAAKuD,mBAAqBvD,KAAK+D,YACrDZ,EAASnD,KAAKmD,OAASnD,KAAK+D,YAC5Bc,EAAW,CAAC,IAAIxB,EAAJ,KAAqBrD,KAArB,CAA2BmD,SAAQI,yBAC5CuB,EAAE,EAAGA,EAAE9E,KAAK+D,YAAae,IAC9BD,EAASH,KAAK,IAAIrB,EAAJ,KACPrD,KADO,CAEVmD,SACAI,qBACAM,KAAMjE,IAAQmF,WAAW/E,KAAK6D,MAAMmB,QAAQF,GAAGG,WAGvD,OAAOJ,IA7HnB,2BA4B0B,IACV1B,EAAuHnD,KAAvHmD,OAAQI,EAA+GvD,KAA/GuD,mBAAoBE,EAA2FzD,KAA3FyD,WAAYC,EAA+E1D,KAA/E0D,YAAaF,EAAkExD,KAAlEwD,SAC7D,MAAO,CAAEL,SAAQI,qBAAoBE,aAAYE,YAD8E3D,KAAxD2D,YACTC,WADiE5D,KAA3C4D,WACVC,KADqD7D,KAA/B6D,KAChBH,cAAaF,WAAUM,SADwB9D,KAAzB8D,SACWC,YADc/D,KAAf+D,eA7BxH,2BAkCQ,OAAOmB,KAAKC,UAAUnF,KAAKsD,QAlCnC,2BAyCQ,OAHKtD,KAAKD,QACNC,KAAKD,MAAQH,IAAQmF,WAAW/E,KAAK6D,OAElC7D,KAAKD,QAzCpB,0BA6CQ,OAAOC,KAAKH,KAAKkB,MA7CzB,4BAiDQ,OAAOf,KAAKH,KAAKmB,QAjDzB,2BAqDQ,OAAOhB,KAAKH,KAAKoB,OArDzB,gCAyDQ,MAAO,CAACjB,KAAKiB,KAAMjB,KAAKgB,MAAOhB,KAAKe,QAzD5C,2BA4De8D,GACP,OAAO9B,OAAOqC,OAAOP,GAChBQ,KAAI,SAAAC,GAAC,OAAIA,EAAE/B,sBACXgC,QAAO,SAACC,EAAGC,GAAJ,OAAUD,EAAIC,SA/DlC,M,qDCWe,SAAS,EAAWC,EAAQC,EAAMC,GAc/C,OAVE,EAjBJ,WACE,GAAuB,qBAAZC,UAA4BA,QAAQC,UAAW,OAAO,EACjE,GAAID,QAAQC,UAAUC,KAAM,OAAO,EACnC,GAAqB,oBAAVC,MAAsB,OAAO,EAExC,IAEE,OADAlG,KAAKmG,UAAUC,SAASC,KAAKN,QAAQC,UAAUhG,KAAM,IAAI,iBAClD,EACP,MAAOwF,GACP,OAAO,GAKLc,GACWP,QAAQC,UAER,SAAoBJ,EAAQC,EAAMC,GAC7C,IAAIJ,EAAI,CAAC,MACTA,EAAEd,KAAK2B,MAAMb,EAAGG,GAChB,IACIW,EAAW,IADGC,SAASC,KAAKH,MAAMX,EAAQF,IAG9C,OADII,GAAO,OAAAa,EAAA,GAAeH,EAAUV,EAAMK,WACnCK,IAIOD,MAAM,KAAMK,WCzBjB,SAAS,EAAiBd,GACvC,IAAIe,EAAwB,oBAARC,IAAqB,IAAIA,SAAQ9F,EA8BrD,OA5BA,EAAmB,SAA0B8E,GAC3C,GAAc,OAAVA,ICRkCiB,EDQEjB,GCPsB,IAAzDW,SAASL,SAASC,KAAKU,GAAIC,QAAQ,kBDOQ,OAAOlB,ECR5C,IAA2BiB,EDUtC,GAAqB,oBAAVjB,EACT,MAAM,IAAImB,UAAU,sDAGtB,GAAsB,qBAAXJ,EAAwB,CACjC,GAAIA,EAAOK,IAAIpB,GAAQ,OAAOe,EAAOM,IAAIrB,GAEzCe,EAAOO,IAAItB,EAAOuB,GAGpB,SAASA,IACP,OAAO,EAAUvB,EAAOc,UAAW,OAAAU,EAAA,GAAepH,MAAMqH,aAW1D,OARAF,EAAQlB,UAAYlD,OAAOuE,OAAO1B,EAAMK,UAAW,CACjDoB,YAAa,CACXE,MAAOJ,EACPK,YAAY,EACZC,UAAU,EACVC,cAAc,KAGX,OAAAjB,EAAA,GAAeU,EAASvB,KAGTA,GAnC1B,mC,yJEGa+B,EAAb,mLAEeC,GAAwB,IACvB3G,EAAS2G,EAAT3G,KACJX,EAASN,KAAKiH,IAAIhG,QACPH,IAAXR,IACAA,EAAS,IAAIuH,EACb7H,KAAKkH,IAAIjG,EAAMX,IAEnBA,EAAOwH,WAAWF,KAT1B,oCAYkBA,GAAwB,IAC3B3G,EAAQ2G,EAAR3G,KACDX,EAASN,KAAKiH,IAAIhG,GACxB,SAAIX,IAAUA,EAAOyH,cAAcH,MACX,IAAhBtH,EAAO0H,MACPhI,KAAKiI,OAAOhH,IAET,KAnBnB,qCAwB0C,IAAzBA,EAAwB,EAAxBA,KAAMD,EAAkB,EAAlBA,MAAOD,EAAW,EAAXA,IAChBT,EAASN,KAAKiH,IAAIhG,GACxB,GAAIX,EAAQ,CACR,IAAMF,EAAOE,EAAO2G,IAAIjG,GACxB,GAAIZ,EACA,OAAOA,EAAK6G,IAAIlG,MA7BhC,0CAoDwBE,EAAcD,EAAgBD,GAC9C,IAAM8D,EAA2B,IAAIqD,EACrC,QAAcpH,IAAVE,EAAqB,CACrB,IAAMV,EAASN,KAAKiH,IAAIhG,GACxB,GAAIX,EAAQ,CAAC,IAAD,uBACR,YAAgBA,EAAO8E,SAAvB,+CAAiC,CAAC,IAAvB+C,EAAsB,QAC7BR,EAAgBS,uBAAuBD,EAAGtD,IAFtC,yFAKT,QAAY/D,IAARC,EAAmB,CAC1B,IAAMT,EAASN,KAAKiH,IAAIhG,GACxB,GAAIX,EAAQ,CACR,IAAMF,EAAOE,EAAO2G,IAAIjG,GACpBZ,GACAuH,EAAgBS,uBAAuBhI,EAAMyE,QAGlD,CACH,IAAMwD,EAAcrI,KAAKsI,YAAY,CAACrH,OAAMD,QAAOD,QACnDsH,GAAeV,EAAgBY,kBAAkBF,EAAYjD,SAAUP,GAE3E,OAAOA,IAzEf,iCA4EehF,EAAW+D,GAClB,IAAMiB,EAAW7E,KAAKsI,YAAYzI,GAClC,GAAIgF,EACA,OAAOA,EAASoC,IAAIrD,KA/EhC,gCAmFc3C,GACN,IAAMX,EAASN,KAAKiH,IAAIhG,GACxB,OAAOX,EAASA,EAAO0C,OAAS,KArFxC,8BAwFY/B,EAAcD,GAClB,IAAMV,EAASN,KAAKiH,IAAIhG,GACxB,GAAIX,EAAQ,CACR,IAAMF,EAAOE,EAAO2G,IAAIjG,GACxB,OAAOZ,EAAOA,EAAK4C,OAAS,GAEhC,MAAO,KA9Ff,4BAkGQ,OAAOhD,KAAKgD,UAlGpB,8CAkC2CwF,EAA2BC,GAAyB,IAAD,uBACtF,YAAgBD,EAAUpD,SAA1B,+CAAoC,CAAC,IAA1BsD,EAAyB,QAChCf,EAAgBY,kBAAkBG,EAAEtD,SAAUqD,IAFoC,qFAlC9F,wCAwC8BE,GAA+E,IAAhDF,EAA+C,uDAAtB,IAAIP,EAAkB,uBACpG,YAAgBS,EAAhB,+CAAuB,CAAC,IAAbrD,EAAY,QACfsD,EAAcH,EAAOxB,IAAI3B,EAAEzB,MAC1B+E,IACDA,EAAc,IAAIhC,IAClB6B,EAAOvB,IAAI5B,EAAEzB,KAAM+E,IAEvBA,EAAY1B,IAAI5B,EAAE1B,WAAY0B,IAPkE,kFASpG,OAAOmD,MAjDf,eAAqC7B,MAuGxBiB,EAAb,mLACeD,GAAwB,IACvB5G,EAAU4G,EAAV5G,MAEJZ,EAAOJ,KAAKiH,IAAIjG,QACPF,IAATV,IACAA,EAAO,IAAI8H,EACXlI,KAAKkH,IAAIlG,EAAOZ,IAEpBA,EAAK0H,WAAWF,KATxB,oCAYkBA,GAAwB,IAC3B5G,EAAS4G,EAAT5G,MACDZ,EAAOJ,KAAKiH,IAAIjG,GACtB,SAAIZ,IAAQA,EAAK2H,cAAcH,MACT,IAAdxH,EAAK4H,MACLhI,KAAKiI,OAAOjH,IAET,OAnBnB,eAAsC4F,MAyBzBsB,EAAb,mLAEeN,GAAwB,IACxB7G,EAAO6G,EAAP7G,IACH8D,EAAW7E,KAAKiH,IAAIlG,QACPD,IAAb+D,IACAA,EAAW,IAAI+B,IACf5G,KAAKkH,IAAInG,EAAK8D,IAElBA,EAASqC,IAAIU,EAAQhE,WAAYgE,KATzC,oCAYkBA,GAAwB,IAC3B7G,EAAmB6G,EAAnB7G,IAAK6C,EAAcgE,EAAdhE,WACNiB,EAAW7E,KAAKiH,IAAIlG,GAC1B,SAAI8D,IAAYA,EAASoD,OAAOrE,MACN,IAAlBiB,EAASmD,MACThI,KAAKiI,OAAOlH,IAET,OAnBnB,eAAoC6F,M,kCC3H7B,IAAMiC,EAAb,WAWI,WAAYvF,GAAiD,IAAnCuB,EAAkC,uDAAJ,GAAI,yBAT3CiE,WAS2C,OAR3CC,eAQ2C,OAPpDC,oBAOoD,OALpDC,0BAKoD,OAHpDC,WAGoD,OAFpDC,gBAEoD,EACxDnJ,KAAK8I,MAAQxF,EACbtD,KAAK+I,UAAY,IAAInC,IAFmC,2BAGxD,YAAsB/B,EAAtB,+CAAgC,CAAC,IAAtB+C,EAAqB,QAC5B5H,KAAK+I,UAAU7B,IACXU,EAAQhE,WACR,IAAIP,IAAauE,KAN+B,mFAXhE,6DAqEqB3G,EAAcD,EAAgBD,GAC3C,IAAMiC,EAAO,CAAC/B,GAGd,YAFUH,IAAVE,GAAuBgC,EAAK0B,KAAK1D,QACzBF,IAARC,GAAqBiC,EAAK0B,KAAK3D,GACxBf,KAAKoJ,oBAAoBzG,YAAYK,KAzEpD,uCA4EsB/B,EAAeD,EAAgBD,GAC7C,YAAaD,IAATG,EACO0G,EAAgBY,kBAAkBvI,KAAK+I,UAAU3D,UAEjDpF,KAAKqJ,cAAcC,oBAAoBrI,EAAMD,EAAOD,KAhFvE,2CAoFiCwI,EAA0BC,QAChC1I,IAAf0I,GACAA,EAAWzF,cAAgBwF,EAAWxF,aACtCyF,EAAWjG,qBAAuBgG,EAAWhG,oBAC7CiG,EAAW3F,OAAS0F,EAAW1F,MAC/B2F,EAAW/F,aAAe8F,EAAW9F,YACrC+F,EAAW9F,cAAgB6F,EAAW7F,cAClC8F,GACAxJ,KAAKyJ,eAAeD,GAExBxJ,KAAK0J,YAAYH,MA9F7B,iCAkGe3B,GACP,IAAM2B,EAAa,IAAIlG,IAAauE,GAC9B4B,EAAaxJ,KAAK+I,UAAU9B,IAAIW,EAAQhE,YAC9C,GAAI4F,EAAY,CACZ,IAAMG,EAAcH,EAAWnF,QADnB,uBAEZ,YAAiBsF,EAAjB,+CAA8B,CAAC,IAApBC,EAAmB,QAC1B5J,KAAKqJ,cAActB,cAAc6B,IAHzB,kFAKZ5J,KAAK6J,qBAAqBN,EAAYC,QAEtCxJ,KAAK6J,qBAAqBN,GAVL,2BAYzB,YAAiBA,EAAWlF,QAA5B,+CAAqC,CAAC,IAA3ByF,EAA0B,QACjC9J,KAAKqJ,cAAcvB,WAAWgC,IAbT,kFAezB9J,KAAK+I,UAAU7B,IAAIU,EAAQhE,WAAY2F,KAjH/C,iCAoHeQ,GACP,IAAMnC,EAAU5H,KAAK+I,UAAU9B,IAAI8C,GACnC,GAAInC,EACA,OAAOA,EAEX,MAAM,IAAIjD,MAAJ,2BAA8BoF,EAA9B,kBAzHd,oCAsJkBA,GACV,IAAMnC,EAAU5H,KAAK+I,UAAU9B,IAAI8C,GACnC,SAAInC,IAAW5H,KAAK+I,UAAUd,OAAO8B,MACjC/J,KAAKyJ,eAAe7B,GACpB5H,KAAKqJ,cAActB,cAAcH,IAC1B,KA3JnB,gDAwLsCoC,GAC9B,IAAMC,EAAY,IAAIjI,IAD8B,uBAEpD,YAAsBhC,KAAK+I,UAAU3D,SAArC,+CAA+C,CAAC,IAArCwC,EAAoC,QAC3CA,EAAQrE,mBAAqBsF,EAAgBqB,eAAetC,EAASoC,GACrEpC,EAAQuC,YAAYF,IAJ4B,kFAMpDjK,KAAKiJ,qBAAuBgB,IA9LpC,kCAiMwBrC,GACZA,EAAQwC,cAAcpK,KAAK8I,QAC3BlB,EAAQuC,YAAYnK,KAAKoJ,uBAnMrC,qCAuM2BxB,GACfA,EAAQwC,cAAcpK,KAAK8I,QAC3BlB,EAAQyC,cAAcrK,KAAKoJ,uBAzMvC,yEA6MoB9F,EAAc0G,GA7MlC,oEA8MY1G,EAAKM,aAAe5D,KAAK4D,WA9MrC,sBA+MkB,IAAIe,MAAM,uDA/M5B,UAkNYrB,EAAKE,WAAaxD,KAAK8I,MAAMtF,SAlNzC,mBAmNiBwG,EAnNjB,sBAoNsB,IAAIrF,MAAM,uDApNhC,OAsNY3E,KAAKsK,0BAA0BN,GAC/BhK,KAAK8I,MAAMtF,SAAWF,EAAKE,SAvNvC,cA0NQxD,KAAK8I,MAAMyB,KAAOjH,EAAKiH,KACvBvK,KAAK8I,MAAMlG,MAAQU,EAAKV,MAEpB5C,KAAK8I,MAAMvH,OAAS+B,EAAK/B,OACzBvB,KAAKkJ,MAAQlJ,KAAKmJ,gBAAarI,EAC/Bd,KAAK8I,MAAMvH,KAAO+B,EAAK/B,MAGvBvB,KAAK8I,MAAMtH,KAAO8B,EAAK9B,KACvBxB,KAAKkJ,MAAQlJ,KAAKmJ,gBAAarI,EAC/Bd,KAAK8I,MAAMtH,GAAK8B,EAAK9B,IApOjC,kBAuOegJ,QAAQC,WAvOvB,uIA0OWC,GACH,IAAM7F,EAAwB,GAE9B,OADA7E,KAAK+I,UAAU4B,SAAQ,SAACrF,EAAGsF,GAAJ,OAAY/F,EAAS+F,GAAMtF,EAAEhC,QAC7C,CACHuH,QAAQ,eAAI7K,KAAK4D,WAAa5D,KAAKsD,MACnCuB,WACA6F,aACAI,cAAehL,KAAKsB,SAjPhC,uCAsBQ,OAAOpB,KAAK+I,UAAUf,OAtB9B,iCA0BQ,OAAOhI,KAAK8I,MAAMlF,aA1B1B,+BA8BQ,OAAO5D,KAAK8I,MAAMtF,WA9B1B,2BAkCQ,OAAOxD,KAAK8I,MAAMvH,OAlC1B,2BAsCQ,OAAOvB,KAAK8I,MAAMyB,OAtC1B,yBA0CQ,OAAOvK,KAAK8I,MAAMtH,KA1C1B,4BA8CQ,OAAOxB,KAAK8I,MAAMlG,QA9C1B,2BAkDQ,OAAO5C,KAAK8I,QAlDpB,+BAsDQ,OAAO9I,KAAK+I,UAAU3D,WAtD9B,oCA0DQ,OAAOpF,KAAKoJ,oBAAoBxG,QA1DxC,0CA6D+B,IAAD,OAKtB,YAJkC9B,IAA9Bd,KAAKiJ,uBACLjJ,KAAKiJ,qBAAuB,IAAIjH,IAChChC,KAAK+I,UAAU4B,SAAQ,SAAArF,GAAC,OAAI,EAAKoE,YAAYpE,OAE1CtF,KAAKiJ,uBAlEpB,qCAgIQ,OAHKjJ,KAAKkJ,QACNlJ,KAAKkJ,MAAQ5H,YAAStB,KAAK8I,MAAMvH,KAAMzB,KAAKsB,QAEzCpB,KAAKkJ,QAhIpB,gCAuIQ,OAHKlJ,KAAKmJ,aACNnJ,KAAKmJ,WAAa7H,YAAStB,KAAK8I,MAAMvH,KAAMvB,KAAK8I,MAAMtH,KAEpDxB,KAAKmJ,aAvIpB,8BA2IQ,OAAInJ,KAAK+K,eAAiB,GAAK/K,KAAKgL,cAAgB,EACzCvJ,KAAKwJ,MAAMjL,KAAKgL,cAAgBhL,KAAK+K,gBAErC,IA9InB,mDAmJQ,OAAOtJ,KAAKwJ,MAAMjL,KAAK8I,MAAMlG,MAAQ5C,KAAKkL,aAnJlD,oCAiKQ,IAAKlL,KAAKgJ,eAAgB,CACtB,IAAMmC,EAAK,IAAIxD,EACf3H,KAAK+I,UACA4B,SAAQ,SAAA/C,GAAO,OAAIA,EAAQvD,QAC3BsG,SAAQ,SAAAS,GAAY,OAAID,EAAGrD,WAAWsD,SAC3CpL,KAAKgJ,eAAiBmC,EAE1B,OAAOnL,KAAKgJ,kBAxKpB,sCA2KkCpB,EAAkBoC,GAAuB,IAC5DxG,EAAoBoE,EAApBpE,SAAUL,EAAUyE,EAAVzE,OACjB,GAAI6G,EAAMqB,OAAS7H,EACf,OAAOL,EAEP,IAAMC,EAAO4G,EAAMA,MAAMxG,GACzB,QAAa1C,IAATsC,EACA,MAAM,IAAIuB,MAAJ,iDAAoDqF,EAAMqB,KAA1D,eAAqE7H,IAE/E,OAAON,YAAUC,EAAQC,OApLrC,M,stBCFO,IAAMkI,EAAb,WAMI,WAAaC,GAAqB,yBAJ1BC,mBAIyB,OAHhBC,UAGgB,OAFhBC,cAEgB,EAC7B1L,KAAKwL,cAAgB,IAAI5E,IACzB5G,KAAKyL,KAAOF,EACZvL,KAAK0L,SAAWH,EAAII,QACpB3L,KAAK0L,SAASE,YAAY5L,MAVlC,mEAcQA,KAAKwL,cAAcK,UAd3B,2KAkBe7L,KAAK0L,SAASI,cAlB7B,oLAqByBhI,GArBzB,mFAuBmBhD,KADPiL,EAAK/L,KAAKwL,cAAcvE,IAAInD,IAtBxC,iCAwBiC9D,KAAK0L,SAASM,UAAUlI,GAxBzD,cAwBkBG,EAxBlB,gBAyBmCjE,KAAK0L,SAASpD,YAAYxE,GAzB7D,UAyBkBe,EAzBlB,QA0BgBZ,EA1BhB,iBA2BgB8H,EAAK,IAAIlD,IAAgB5E,EAAQlB,OAAOqC,OAAOP,IAC/C7E,KAAKwL,cAActE,IAAIpD,EAAUiI,GA5BjD,8BA8BsB,IAAIpH,MAAM,qBAAuBb,GA9BvD,iCAiCeiI,GAjCf,iLAoCoB9H,GApCpB,8EAqCcgI,EAAcjM,KAAKwL,cAAcvE,IAAIhD,EAAOL,aArC1D,oBAuCgBoG,OAAQlJ,EACRmL,EAAYzI,WAAaS,EAAOT,SAxChD,iCAyCqCxD,KAAKyL,KAAKS,qBAzC/C,mBAyC8EjI,EAAOT,SAzCrF,gBAyCqE2I,SAzCrE,aAyCgBnC,EAzChB,gCA2CkBiC,EAAYG,UAAUnI,EAAQ+F,GA3ChD,gCA6CYhK,KAAKwL,cAActE,IAAIjD,EAAOL,WAAY,IAAIiF,IAAgB5E,IA7C1E,iCA+CejE,KAAK0L,SAASU,UAAUnI,IA/CvC,mLAkDsBH,GAlDtB,iFAmDsB9D,KAAKqM,eAAevI,GAnD1C,uCAmDqDe,UAnDrD,uLAsD2Bf,EAAkBjE,GAtD7C,yFAuDkCG,KAAKqM,eAAevI,GAvDtD,YAuDcmI,EAvDd,QAwDwB5C,cAxDxB,qBAyDkBxE,EAAWoH,EAAY5C,cAAcf,YAAYzI,IAzDnE,yCA2DuBgF,GA3DvB,aA8Dc,IAAIF,MAAM,qBA9DxB,oLAiEsBb,EAAkBe,GAjExC,mGAkE4B7E,KAAKqM,eAAevI,GAlEhD,OAmEQ,IADMwI,EAlEd,mCAmEQ,EAAsBzH,EAAtB,+CAAW+C,EAAqB,QAC5B0E,EAAMC,WAAW3E,GApE7B,kQAsEe5H,KAAK0L,SAASc,YAAY3H,IAtEzC,+MAyEqBf,EAAkBiG,GAzEvC,iFA0EsB/J,KAAKqM,eAAevI,GA1E1C,mBA0EgEiG,EA1EhE,yBA0EqD0C,WA1ErD,4LA6EuB3I,GA7EvB,wEA8EQ9D,KAAKwL,cAAcvD,OAAOnE,GA9ElC,kBA+Ee9D,KAAK0L,SAASgB,aAAa5I,IA/E1C,oLAkFwBA,EAAkBiG,GAlF1C,iFAmF4B/J,KAAKqM,eAAevI,GAnFhD,qBAoFciE,cAAcgC,GApF5B,kBAqFe/J,KAAK0L,SAAS3D,cAAcgC,IArF3C,mLAwF6Bc,GAxF7B,qGAyFeL,QAAQmC,IAAI9B,EAAQxF,KAAI,SAAAI,GAAC,OAAI,EAAK2G,UAAU3G,QAzF3D,iLA4FkCZ,GA5FlC,qGA6Fe2F,QAAQmC,IAAI9H,EAASQ,KAAI,SAAAuC,GAAO,OAAI,EAAK2E,WAAW3E,QA7FnE,4KAgG6BA,GAhG7B,iFAiG4B5H,KAAKqM,eAAezE,EAAQ9D,UAjGxD,qBAkGcyI,WAAW3E,GAlGzB,kBAmGe5H,KAAK0L,SAASc,YAAY,CAAC5E,KAnG1C,6KAsGiBgF,GAtGjB,oFAuGe/B,EAAiC+B,EAAjC/B,QAAShG,EAAwB+H,EAAxB/H,SAAU6F,EAAckC,EAAdlC,WAEpBmC,EAAkB9J,OACnB+J,QAAQpC,GACRrF,KAAI,6CAAuBzB,WAAvB,eA3GjB,KA4Gc4G,QA5Gd,KA6GYxK,KAAK+M,WAAWhK,OAAOqC,OAAOyF,IA7G1C,KA8GY7K,KAAKgN,gBAAgBjK,OAAOqC,OAAOP,IA9G/C,SA+GmB7E,KAAKyL,KAAKwB,qBA/G7B,mBA+GiEJ,EA/GjE,YA+GmDK,cA/GnD,2CA4GsBP,IA5GtB,8NAAArH,EAAA,oFAqHqB,GArHrB,KAsHsB,GAtHtB,SAuHqCtF,KAAKyL,KAAKwB,qBAvH/C,8BAuHqEE,gBAvHrE,+BAwH2BrN,KAAKsB,MAJlBwL,EApHd,CAqHY/B,QArHZ,KAsHYhG,SAtHZ,KAuHY6F,WAvHZ,KAwHYI,cAxHZ,WA0H8BN,QA1H9B,KA0H0CzH,OA1H1C,UA0H4D/C,KAAKoN,kBA1HjE,gCA0HwF,SAAAxC,GAAE,OAAI,EAAKyB,eAAezB,IA1HlH,UA0HiD5H,KA1HjD,gBA0HoFqC,IA1HpF,qBA0HsCsH,IA1HtC,wBA0Hc9B,EA1Hd,sCA2HyBA,EA3HzB,mEA6HY,IAFOkB,EA3HnB,QA4HYa,EAAK/B,QAAQkB,EAAGnI,YAAcmI,EAAGzI,KA5H7C,6BA6HY,EAAgByI,EAAGlH,SAAnB,+CAAWS,EAAkB,QACzBsH,EAAK/H,SAASS,EAAE1B,YAAc0B,EAAEhC,KA9HhD,4gBAiIesJ,GAjIf","file":"static/js/22.763d7f86.chunk.js","sourcesContent":["import { YMD } from \"../api\";\n\nexport class DateDay implements YMD {\n    private readonly _date: Date;\n\n    constructor(date = new Date()) {\n        this._date = new Date(\n            date.getFullYear(), \n            date.getMonth(), \n            date.getDate());\n    }\n\n    clone() {\n        return new DateDay(this._date);\n    }\n\n    get year () {\n        return this._date.getFullYear();\n    }\n\n    get month () {\n        return this._date.getMonth();\n    }\n\n    get day () {\n        return this._date.getDate();\n    }\n\n    static fromTimeMs (timestampMs: number) {\n        return new DateDay(new Date(timestampMs));\n    }\n\n    static fromYMD (date: YMD) {\n        return new DateDay(new Date(date.year, date.month, date.day));\n    }\n\n    get timeMs () {\n        return this._date.getTime();\n    }\n    \n    get isToday() {\n        return DateDay.isToday(this);\n    }\n\n    /**\n     * @returns current object instance with days added to previous date\n     */\n    addDays (days: number) {\n        this._date.setDate(this._date.getDate() + days);\n        return this;\n    }\n\n    /**\n     * @returns current object instance with months added to previous date\n     */\n    addMonths (months: number) {\n        this._date.setMonth(this._date.getMonth() + months);\n        return this;\n    }\n\n    /**\n     * @returns current object instance with years added to previous date\n     */\n    addYears (years: number) {\n        this._date.setFullYear(this._date.getFullYear() + years);\n        return this;\n    }\n\n    static isToday(date: YMD) {\n        const now = new Date();\n        return date.day === now.getDate() && \n            date.month === now.getMonth() && \n            date.year === now.getFullYear();\n    }\n\n    get shortString () {\n        const dt = new Intl.DateTimeFormat(\n            undefined, \n            {day: 'numeric', month: 'long', year: 'numeric'});\n        return dt.format(this._date);\n    }\n\n    equals(date: DateDay) {\n        return this._date.getTime() === date._date.getTime();\n    }\n}","\nconst DAY_MS = 1000*60*60*24;\n\n/**\n * Get difference between 2 dates in days, including from and to dates.\n * @param from - Starting period timestamp\n * @param to - Ending period timestamp\n */\nexport function dateDiff(from: number, to: number) {\n    return Math.floor((to - from)/DAY_MS) + 1;\n}\n\n/** \n * @returns Date (without time) as string type in ISO format\n */\nexport function getISODateString (date = new Date()) {\n    return date.toISOString().slice(0,10);\n}\n\n/** \n * @returns month name from Date input\n */\nexport function monthToString (month: number) {\n    const dt = new Intl.DateTimeFormat(undefined, {month: 'long'});\n    return dt.format(new Date(2000, month, 1));\n}\n\n/** \n * @returns month and year name from Date input\n */\nexport function monthYearToString (year: number, month: number) {\n    const dt = new Intl.DateTimeFormat(undefined, {month: 'long', year: 'numeric'});\n    return dt.format(new Date(year, month, 1));\n}\n","import { ObjectMap } from \"../api\";\n\ndeclare type IndexType = number|string;\n\nexport class NestedTotal {\n    private _total: number;\n    private _subTotals: ObjectMap<NestedTotal>;\n\n    constructor(){\n        this._total = 0;\n        this._subTotals = {};\n    }\n\n    add(n: number, subTotalIndexes?: IndexType[]): number{\n        this._total += n;\n        const subTotal = this._getSubTotal(subTotalIndexes);\n        subTotal && subTotal.add(n, subTotalIndexes);\n        return this._total;\n    }\n\n    subtract(n: number, subTotalIndexes?: IndexType[]): number {\n        return this.add(-n, subTotalIndexes);\n    }\n\n    private _getSubTotal(subTotalIndexes?: IndexType[]): NestedTotal|undefined {\n        if (subTotalIndexes !== undefined) {\n            const index = subTotalIndexes.shift();\n            if (index !== undefined) {\n                if (!(index in this._subTotals)) {\n                    this._subTotals[index] = new NestedTotal();\n                }\n                return this._subTotals[index];\n            }\n        }\n        return undefined;\n    }\n\n    get total() {\n        return this._total;\n    }\n\n    get avg() {\n        return this._total / Object.keys(this._subTotals).length;\n    }\n\n    getSubtotal(indexes: IndexType[]): number {\n        const index = indexes.shift();\n        if (index !== undefined) {\n            if (index in this._subTotals) {\n                return this._subTotals[index].getSubtotal(indexes);\n            } else {\n                return 0;\n            }\n        }\n        return this.total;\n    }\n\n    getAverage(indexes: IndexType[]): number {\n        const index = indexes.shift();\n        if (index !== undefined) {\n            if (index in this._subTotals) {\n                return this._subTotals[index].getAverage(indexes);\n            } else {\n                return 0;\n            }\n        }\n        return this.avg;\n    }\n\n    get indexes () {\n        return Object.keys(this._subTotals);\n    }\n}\n","\nexport default function applyRate (amount: number, rate: number) {\n    return amount / rate;\n}\n","import { Budget, Expense } from \"../api\";\nimport { NestedTotal } from \"./NestedTotal\";\nimport { DateDay } from \"./DateDay\";\n\nexport class ExpenseModel implements Expense {\n\n    private _date?: DateDay;\n    readonly amount: number;\n    amountBaseCurrency: number;\n    readonly currency: string;\n    readonly categoryId: string;\n    readonly countryCode: string;\n    readonly description?: string;\n    readonly identifier: string;\n    readonly when: number;\n    readonly budgetId: string;\n    readonly splitInDays: number;\n\n    constructor (info: Expense) {\n        this.identifier = info.identifier;\n        this.amountBaseCurrency = info.amountBaseCurrency;\n        this.amount = info.amount;\n        this.currency = info.currency;\n        this.categoryId = info.categoryId;\n        this.countryCode = info.countryCode;\n        this.description = info.description;\n        this.when = info.when;\n        this.budgetId = info.budgetId;\n        this.splitInDays = info.splitInDays > 0 ? info.splitInDays : 1;\n        this.validate();\n    }\n\n    get info (): Expense {\n        const { amount, amountBaseCurrency, categoryId, countryCode, currency, description, identifier, when, budgetId, splitInDays} = this;\n        return { amount, amountBaseCurrency, categoryId, description, identifier, when, countryCode, currency, budgetId, splitInDays};\n    }\n\n    get json (): string {\n        return JSON.stringify(this.info);\n    }\n\n    get date () {\n        if (!this._date) {\n            this._date = DateDay.fromTimeMs(this.when);\n        }\n        return this._date;\n    }\n\n    get day () {\n        return this.date.day;\n    }\n\n    get month () {\n        return this.date.month;\n    }\n\n    get year () {\n        return this.date.year;\n    }\n\n    get dateParts (): number[] {\n        return [this.year, this.month, this.day];\n    }\n\n    static sum(expenses: Iterable<Expense>){\n        return Object.values(expenses)\n            .map(e => e.amountBaseCurrency)\n            .reduce((a, b) => a + b);\n    }\n\n    inBudgetDates (budget: Budget) {\n        return this.when <= budget.to && this.when >= budget.from;\n    }\n\n    inDates (fromMs: number, toMs: number) {\n        return this.when <= toMs && this.when >= fromMs;\n    }\n\n    addToTotals(totals: NestedTotal) {\n        for (const em of this.split()) {\n            totals.add(em.amountBaseCurrency, em.dateParts);\n        }\n    }\n\n    subtractTotal(totals: NestedTotal) {\n        for (const em of this.split()) {\n            totals.subtract(em.amountBaseCurrency, em.dateParts);\n        }\n    }\n\n    validate () {\n        const fieldErrors = [];\n        if (this.budgetId === undefined) {\n            fieldErrors.push('budget identifier');\n        }\n        if (this.amountBaseCurrency === undefined) {\n            fieldErrors.push('amount in base currency');\n        }\n        if (this.countryCode.length !== 2) {\n            fieldErrors.push('country code');\n        }\n        if (this.currency.length !== 3) {\n            fieldErrors.push('currency code');\n        }\n        if (fieldErrors.length > 0) {\n            throw Error(`Invalid expense (${this.identifier}) fields: ${fieldErrors.join(', ')}`);\n        }\n    }\n\n    /** \n     * @returns List of split expenses, first element will be current split expense\n     */\n    split(): ExpenseModel[] {\n        if (this.splitInDays < 1) {\n            throw Error('You cannot split an expense in less than one piece');\n        } else if (this.splitInDays === 1) {\n            return [this];\n        } else {\n            const amountBaseCurrency =  this.amountBaseCurrency / this.splitInDays;\n            const amount = this.amount / this.splitInDays;\n            const expenses = [new ExpenseModel({...this, amount, amountBaseCurrency})];\n            for (let i=1; i<this.splitInDays; i++) {\n                expenses.push(new ExpenseModel({\n                    ...this,\n                    amount, \n                    amountBaseCurrency,\n                    when: DateDay.fromTimeMs(this.when).addDays(i).timeMs,\n                }));\n            }\n            return expenses;\n        }\n    }\n}\n","import setPrototypeOf from \"./setPrototypeOf\";\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf\";\nimport setPrototypeOf from \"./setPrototypeOf\";\nimport isNativeFunction from \"./isNativeFunction\";\nimport construct from \"./construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","import { ExpenseModel } from \"./ExpenseModel\";\nimport { YMD } from \"../api\";\n\nexport class ExpensesYearMap extends Map<number, ExpensesMonthMap> {\n\n    addExpense(expense: ExpenseModel) {\n        const { year } = expense;\n        let months = this.get(year);\n        if (months === undefined) {\n            months = new ExpensesMonthMap();\n            this.set(year, months);\n        }\n        months.addExpense(expense);\n    }\n\n    deleteExpense(expense: ExpenseModel) {\n        const {year} = expense;\n        const months = this.get(year);\n        if (months && months.deleteExpense(expense)) {\n            if (months.size === 0) {\n                this.delete(year);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    getExpenses({year, month, day}: YMD) {\n        const months = this.get(year);\n        if (months) {\n            const days = months.get(month);\n            if (days) {\n                return days.get(day);\n            }\n        }\n    }\n\n    private static addDailyExpensesByDate (inputDays: ExpensesDayMap, output: ExpensesDayMap) {\n        for (const d of inputDays.values()) {\n            ExpensesYearMap.addExpensesByDate(d.values(), output);\n        }\n    }\n\n    static addExpensesByDate (input: Iterable<ExpenseModel>, output: ExpensesDayMap = new ExpensesDayMap()) {\n        for (const e of input) {\n            let expensesMap = output.get(e.when);\n            if (!expensesMap) {\n                expensesMap = new Map();\n                output.set(e.when, expensesMap);\n            }\n            expensesMap.set(e.identifier, e);\n        }\n        return output;\n    }\n\n    getAllGroupedByDate(year: number, month?: number, day?: number): ExpensesDayMap | undefined {\n        const expenses: ExpensesDayMap = new ExpensesDayMap();\n        if (month === undefined) {\n            const months = this.get(year);\n            if (months) {\n                for (const m of months.values()) {\n                    ExpensesYearMap.addDailyExpensesByDate(m, expenses);\n                }    \n            }\n        } else if (day === undefined) {\n            const months = this.get(year);\n            if (months) {\n                const days = months.get(month);\n                if (days) {\n                    ExpensesYearMap.addDailyExpensesByDate(days, expenses);\n                }\n            }\n        } else {\n            const dayExpenses = this.getExpenses({year, month, day});\n            dayExpenses && ExpensesYearMap.addExpensesByDate(dayExpenses.values(), expenses);\n        }\n        return expenses;\n    }\n\n    getExpense(date: YMD, identifier: string){\n        const expenses = this.getExpenses(date);\n        if (expenses) {\n            return expenses.get(identifier);\n        }\n    }\n\n    getMonths(year: number): Iterable<number> {\n        const months = this.get(year);\n        return months ? months.keys() : [];\n    }\n\n    getDays(year: number, month: number): Iterable<number> {\n        const months = this.get(year);\n        if (months) {\n            const days = months.get(month);\n            return days ? days.keys() : [];\n        }\n        return [];\n    }\n\n    get years(): Iterable<number> {\n        return this.keys();\n    }\n\n}\n\nexport class ExpensesMonthMap extends Map<number, ExpensesDayMap> { \n    addExpense(expense: ExpenseModel) {\n        const { month } = expense;\n        \n        let days = this.get(month);\n        if (days === undefined) {\n            days = new ExpensesDayMap();\n            this.set(month, days);\n        }\n        days.addExpense(expense);\n    }\n\n    deleteExpense(expense: ExpenseModel) {\n        const {month} = expense;\n        const days = this.get(month);\n        if (days && days.deleteExpense(expense)) {\n            if (days.size === 0) {\n                this.delete(month);\n            }\n            return true;\n        }\n        return false;\n    }\n}\n\nexport class ExpensesDayMap extends Map<number, Map<string, ExpenseModel>> { \n\n    addExpense(expense: ExpenseModel) {\n        const {day} = expense;\n        let expenses = this.get(day);\n        if (expenses === undefined) {\n            expenses = new Map<string, ExpenseModel>();\n            this.set(day, expenses);\n        }\n        expenses.set(expense.identifier, expense);\n    }\n\n    deleteExpense(expense: ExpenseModel) {\n        const {day, identifier} = expense;\n        const expenses = this.get(day);\n        if (expenses && expenses.delete(identifier)) {\n            if (expenses.size === 0) {\n                this.delete(day);\n            }\n            return true;\n        }\n        return false;\n    }\n    \n}","import { Budget, Expense, CategoriesMap, CurrencyRates, ExpensesMap, ExportDataSet } from \"../api\";\nimport { dateDiff } from \"./date\";\nimport { NestedTotal } from \"./NestedTotal\";\nimport { ExpenseModel } from \"./ExpenseModel\";\nimport applyRate from \"./utils/applyRate\";\nimport { BudgetModel } from \"./BudgetModel\";\nimport { ExpensesYearMap, ExpensesDayMap } from \"./ExpensesYearMap\";\n\nexport class BudgetModelImpl implements BudgetModel {\n\n    private readonly _info: Budget;\n    private readonly _expenses: Map<string, ExpenseModel>;\n    private _expenseGroups?: ExpensesYearMap;\n\n    private _nestedTotalExpenses?: NestedTotal;\n\n    private _days?: number;\n    private _totalDays?: number;\n\n    constructor(info: Budget, expenses: Iterable<Expense> = []) {\n        this._info = info;\n        this._expenses = new Map();\n        for (const expense of expenses) {\n            this._expenses.set(\n                expense.identifier, \n                new ExpenseModel(expense));\n        }\n    }\n\n    get numberOfExpenses() {\n        return this._expenses.size;\n    }\n\n    get identifier() {\n        return this._info.identifier;\n    }\n\n    get currency() {\n        return this._info.currency;\n    }\n\n    get from() {\n        return this._info.from;\n    }\n\n    get name() {\n        return this._info.name;\n    }\n\n    get to() {\n        return this._info.to;\n    }\n\n    get total() {\n        return this._info.total;\n    }\n\n    get info() {\n        return this._info;\n    }\n\n    get expenses() {\n        return this._expenses.values();\n    }\n\n    get totalExpenses() {\n        return this.nestedTotalExpenses.total;\n    }\n\n    get nestedTotalExpenses() {\n        if (this._nestedTotalExpenses === undefined) {\n            this._nestedTotalExpenses = new NestedTotal();\n            this._expenses.forEach(e => this._addToTotal(e));\n        }\n        return this._nestedTotalExpenses;\n    }\n\n    getTotalExpenses(year: number, month?: number, day?: number) {\n        const keys = [year];\n        month !== undefined && keys.push(month);\n        day !== undefined && keys.push(day);\n        return this.nestedTotalExpenses.getSubtotal(keys);\n    }\n\n    getExpensesByDay (year?: number, month?: number, day?: number): ExpensesDayMap | undefined {\n        if (year === undefined) {\n            return ExpensesYearMap.addExpensesByDate(this._expenses.values());\n        } else {\n            return this.expenseGroups.getAllGroupedByDate(year, month, day);\n        }\n    }\n\n    private _updateTotalExpenses(newExpense: ExpenseModel, oldExpense?: ExpenseModel) {\n        if (oldExpense === undefined ||\n            oldExpense.splitInDays !== newExpense.splitInDays ||\n            oldExpense.amountBaseCurrency !== newExpense.amountBaseCurrency ||\n            oldExpense.when !== newExpense.when ||\n            oldExpense.categoryId !== newExpense.categoryId ||\n            oldExpense.countryCode !== newExpense.countryCode) {\n            if (oldExpense) {\n                this._subtractTotal(oldExpense);\n            }\n            this._addToTotal(newExpense);\n        }\n    }\n\n    setExpense(expense: Expense) {\n        const newExpense = new ExpenseModel(expense);\n        const oldExpense = this._expenses.get(expense.identifier);\n        if (oldExpense) {\n            const oldExpenses = oldExpense.split();\n            for (const oe of oldExpenses) {\n                this.expenseGroups.deleteExpense(oe);\n            }\n            this._updateTotalExpenses(newExpense, oldExpense);\n        } else {\n            this._updateTotalExpenses(newExpense);\n        }\n        for (const ne of newExpense.split()) {\n            this.expenseGroups.addExpense(ne);\n        }\n        this._expenses.set(expense.identifier, newExpense);\n    }\n\n    getExpense(expenseId: string): ExpenseModel {\n        const expense = this._expenses.get(expenseId);\n        if (expense) {\n            return expense;\n        }\n        throw new Error(`Expense with ID \"${expenseId}\" not found`);\n    }\n\n    get daysUntilToday() {\n        if (!this._days) {\n            this._days = dateDiff(this._info.from, Date.now());\n        }\n        return this._days;\n    }\n\n    get totalDays() {\n        if (!this._totalDays) {\n            this._totalDays = dateDiff(this._info.from, this._info.to);\n        }\n        return this._totalDays;\n    }\n\n    get average() {\n        if (this.daysUntilToday > 0 && this.totalExpenses > 0) {\n            return Math.round(this.totalExpenses / this.daysUntilToday);\n        } else {\n            return 0;\n        }\n    }\n\n    get expectedDailyExpensesAverage() {\n        return Math.round(this._info.total / this.totalDays);\n    }\n\n    deleteExpense(expenseId: string) {\n        const expense = this._expenses.get(expenseId);\n        if (expense && this._expenses.delete(expenseId)) {\n            this._subtractTotal(expense);\n            this.expenseGroups.deleteExpense(expense);\n            return true;\n        }\n        return false;\n    }\n\n    get expenseGroups() {\n        if (!this._expenseGroups) {\n            const eg = new ExpensesYearMap();\n            this._expenses\n                .forEach(expense => expense.split()\n                .forEach(splitExpense => eg.addExpense(splitExpense)));\n            this._expenseGroups = eg;\n        }\n        return this._expenseGroups;\n    }\n\n    private static _getBaseAmount(expense: Expense, rates: CurrencyRates) {\n        const {currency, amount} = expense;\n        if (rates.base === currency) {\n            return amount;\n        } else {\n            const rate = rates.rates[currency];\n            if (rate === undefined) {\n                throw new Error(`Cannot get currency exchange rate from ${rates.base} to ${currency}`);\n            }\n            return applyRate(amount, rate);\n        }\n    }\n\n    private _updateExpensesBaseAmount(rates: CurrencyRates) {\n        const newTotals = new NestedTotal();\n        for (const expense of this._expenses.values()) {\n            expense.amountBaseCurrency = BudgetModelImpl._getBaseAmount(expense, rates);\n            expense.addToTotals(newTotals);\n        }\n        this._nestedTotalExpenses = newTotals;\n    }\n\n    private _addToTotal(expense: ExpenseModel) {\n        if (expense.inBudgetDates(this._info)) {\n            expense.addToTotals(this.nestedTotalExpenses);\n        }\n    }\n\n    private _subtractTotal(expense: ExpenseModel) {\n        if (expense.inBudgetDates(this._info)) {\n            expense.subtractTotal(this.nestedTotalExpenses);\n        }\n    }\n\n    async setBudget(info: Budget, rates?: CurrencyRates) {\n        if (info.identifier !== this.identifier) {\n            throw new Error('Cannot update budget information with different IDs');\n        }\n\n        if (info.currency !== this._info.currency) {\n            if (!rates) {\n                throw new Error('Required conversion rates to update budget currency');\n            }\n            this._updateExpensesBaseAmount(rates);\n            this._info.currency = info.currency;\n        }\n\n        this._info.name = info.name;\n        this._info.total = info.total;\n\n        if (this._info.from !== info.from) {\n            this._days = this._totalDays = undefined;\n            this._info.from = info.from;\n        }\n\n        if (this._info.to !== info.to) {\n            this._days = this._totalDays = undefined;\n            this._info.to = info.to;\n        }\n\n        return Promise.resolve();\n    }\n\n    export(categories: CategoriesMap): ExportDataSet {\n        const expenses: ExpensesMap = {};\n        this._expenses.forEach((e, id) => (expenses[id] = e.info));\n        return {\n            budgets: { [this.identifier]: this.info },\n            expenses,\n            categories,\n            lastTimeSaved: Date.now()\n        };\n    }\n}\n","import { Budget, Expense, ExportDataSet, BudgetTracker, YMD } from \"../../api\";\nimport { BudgetModel } from \"../BudgetModel\";\nimport { BudgetsStore } from \"./interfaces\";\nimport { AppStorageApi, StorageObserver } from \"../../services/storage/StorageApi\";\nimport { BudgetModelImpl } from \"../BudgetModelImpl\";\n\nexport class BudgetsStoreImpl implements BudgetsStore, StorageObserver {\n\n    private _budgetModels: Map<string, BudgetModel>;\n    private readonly _app: BudgetTracker;\n    private readonly _storage: AppStorageApi;\n\n    constructor (app: BudgetTracker) {\n        this._budgetModels = new Map();\n        this._app = app;\n        this._storage = app.storage;\n        this._storage.addObserver(this);\n    }\n\n    onStorageDataChanged () {\n        this._budgetModels.clear();\n    }\n\n    async getBudgetsIndex(){\n        return this._storage.getBudgets();\n    }\n\n    async getBudgetModel(budgetId: string) {\n        let bm = this._budgetModels.get(budgetId);\n        if (bm === undefined) {\n            const budget = await this._storage.getBudget(budgetId);\n            const expenses = await this._storage.getExpenses(budgetId);\n            if (budget) {\n                bm = new BudgetModelImpl(budget, Object.values(expenses));\n                this._budgetModels.set(budgetId, bm);\n            } else {\n                throw new Error('Budget not found: ' + budgetId);\n            }\n        }\n        return bm;\n    }\n\n    async setBudget(budget: Budget) {\n        const budgetModel = this._budgetModels.get(budget.identifier);\n        if (budgetModel) {\n            let rates = undefined;\n            if (budgetModel.currency !== budget.currency) {\n                rates = await (await this._app.getCurrenciesStore()).getRates(budget.currency);\n            }\n            await budgetModel.setBudget(budget, rates);\n        } else {\n            this._budgetModels.set(budget.identifier, new BudgetModelImpl(budget));\n        }\n        return this._storage.setBudget(budget); \n    }\n\n    async getExpenses(budgetId: string) {\n        return (await this.getBudgetModel(budgetId)).expenses;\n    }\n\n    async getExpensesByDay(budgetId: string, date: YMD) {\n        const budgetModel = await this.getBudgetModel(budgetId);\n        if (budgetModel.expenseGroups) {\n            const expenses = budgetModel.expenseGroups.getExpenses(date);\n            if (expenses) {\n                return expenses;\n            }\n        }\n        throw new Error('No expenses found');\n    }\n\n    async setExpenses(budgetId: string, expenses: Expense[]) {\n        const model = await this.getBudgetModel(budgetId);\n        for (const expense of expenses) {\n            model.setExpense(expense);\n        }\n        return this._storage.setExpenses(expenses);\n    }\n\n    async getExpense(budgetId: string, expenseId: string){\n        return (await this.getBudgetModel(budgetId)).getExpense(expenseId);\n    }\n\n    async deleteBudget(budgetId: string) {\n        this._budgetModels.delete(budgetId);\n        return this._storage.deleteBudget(budgetId);\n    }\n\n    async deleteExpense(budgetId: string, expenseId: string) {\n        const model = await this.getBudgetModel(budgetId);\n        model.deleteExpense(expenseId);\n        return this._storage.deleteExpense(expenseId);\n    }\n\n    private async setBudgets(budgets: Budget[]) {\n        return Promise.all(budgets.map(b => this.setBudget(b)));\n    }\n\n    private async setExpensesList(expenses: Expense[]) {\n        return Promise.all(expenses.map(expense => this.setExpense(expense)));\n    }\n\n    private async setExpense(expense: Expense) {\n        const model = await this.getBudgetModel(expense.budgetId);\n        model.setExpense(expense);\n        return this._storage.setExpenses([expense]);\n    }\n\n    async import(data: ExportDataSet) {\n        const {budgets, expenses, categories} = data;\n        // Keep BC compatibility Category.id -> Category.identifier\n        const fixedCategories = Object\n            .entries(categories)\n            .map(([identifier, c]) => ({identifier, ...c}));\n        await Promise.all([\n            this.setBudgets(Object.values(budgets)), \n            this.setExpensesList(Object.values(expenses)), \n            (await this._app.getCategoriesStore()).setCategories(fixedCategories)\n        ]);\n    }\n\n    async export() {\n        const data: ExportDataSet = {\n            budgets: {},\n            expenses: {},\n            categories: await (await this._app.getCategoriesStore()).getCategories(),\n            lastTimeSaved: Date.now()\n        };\n        const budgets = await Promise.all(Object.keys(await this.getBudgetsIndex()).map(id => this.getBudgetModel(id)));\n        for (const bm of budgets) {\n            data.budgets[bm.identifier] = bm.info;\n            for (const e of bm.expenses) {\n                data.expenses[e.identifier] = e.info;\n            }\n        }\n        return data;\n    }\n}\n"],"sourceRoot":""}