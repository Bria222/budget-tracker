{"version":3,"sources":["serviceWorker.ts","components/Header.tsx","components/snackbars.tsx","components/ExportCard.tsx","App.tsx","services/storage/DataSync.ts","services/storage/AppStorageManager.ts","api.ts","domain/utils/uuid.ts","services/storage/IndexedDb.ts","services/LocalizationStoreImpl.ts","index.tsx","BudgetTrackerImpl.ts"],"names":["isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","Header","props","AppBar","position","Toolbar","Typography","color","variant","style","flexGrow","title","actions","SnackbarApp","React","useState","close","setClose","type","messageId","handleClose","Snackbar","anchorOrigin","vertical","horizontal","open","autoHideDuration","onClose","ContentProps","message","id","action","IconButton","key","aria-label","onClick","SnackbarInfo","download","fileName","Date","toLocaleDateString","ExportCard","info","setInfo","json","setJson","loc","url","blob","Blob","URL","createObjectURL","a","clipboard","writeText","get","JSON","stringify","dataToExport","Card","CardHeader","CardContent","description","extra","CardActions","disabled","href","Content","Link","Divider","marginTop","marginBottom","target","width","verticalAlign","App","exportData","setExportData","btApp","localization","useEffect","getBudgetsStore","store","export","warn","undefined","initExportData","Fragment","CssBaseline","Container","maxWidth","Box","mt","DataSync","from","to","name","this","constructor","debug","pending","import","SyncDirection","EntityNames","AppStorageManager","local","remote","observers","Set","observer","add","delete","forEach","o","onStorageDataChanged","deviceId","localStorage","getItem","nanoid","setItem","sync","Promise","all","getLastTimeSaved","remoteTime","localTime","notifyObservers","budgetId","getBudget","getBudgets","getExpenses","budget","timestamp","now","localPromise","setBudget","deleteBudget","expenseId","getExpense","expenses","setExpenses","deleteExpense","categoryId","getCategory","getCategories","categories","setCategories","identifier","deleteCategory","keyPath","IndexedDb","version","_db","openDB","upgrade","db","createObjectStore","Budgets","createIndex","Categories","Expenses","storage","persist","enablePersistentStorage","createDb","getDb","bound","IDBKeyRange","upperBound","getAllFromIndex","budgetsResult","budgetMap","b","put","deleted","setLastTimeSaved","tx","transaction","done","expensesResult","e","Error","getAll","expensesMap","expense","categoriesResult","c","category","objectStore","data","dbProps","lastTimeSaved","budgets","getAllExpenses","parseInt","toString","DEFAULT_LANG","LANG_STRINGS","LocalizationImpl","lang","strings","slice","initStrings","loaded","default","Object","entries","k","v","_firestore","_auth","_authPromise","_budgetsStore","_categoriesStore","_iconsStore","_currenciesStore","_countriesStore","onAuth","uid","initFirestore","setRemote","initBgAuth","language","getAuth","getUserId","FirestoreApi","getAuthPromise","subscribe","auth","AuthApiImpl","bs","BudgetsStoreImpl","imported","CategoriesStoreImpl","IconsStoreImpl","currencies","CurrenciesStoreImpl","CountriesStoreImpl","ReactDOM","render","document","getElementById","process","origin","addEventListener","fetch","response","contentType","headers","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.4c65b21b.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from \"react\";\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from \"@material-ui/core/Typography\";\n\nexport interface HeaderProps {\n    title: string;\n    actions?: React.ReactNode;\n}\nexport const Header: React.FC<HeaderProps> = (props) => {\n\n    return (\n    <AppBar position='sticky'>\n        <Toolbar>\n            <Typography color='inherit' variant='h6' style={{flexGrow: 1}}>{props.title}</Typography>\n            { props.actions }\n        </Toolbar>\n    </AppBar>);\n}\n","import React from 'react';\nimport IconButton from '@material-ui/core/IconButton';\nimport Snackbar from '@material-ui/core/Snackbar';\nimport CloseIcon from '@material-ui/icons/Close';\n\ninterface SnackbarAppProps {\n    message: string;\n    type?: string;\n}\n\nexport const SnackbarApp: React.FC<SnackbarAppProps> = (props) => {\n    const [close, setClose] = React.useState();\n    const type = props.type || 'default';\n    const messageId = `${type}-message-id`;\n\n    function handleClose () {\n        setClose(true);\n    }\n\n    return (\n    <Snackbar\n        anchorOrigin={{ vertical: 'bottom', horizontal: 'left', }}\n        open={!close}\n        autoHideDuration={6000}\n        onClose={handleClose}\n        ContentProps={{ 'aria-describedby': messageId }}\n        message={<span id={messageId}>{props.message}</span>}\n        action={[\n            <IconButton\n                key=\"close\"\n                aria-label=\"Close\"\n                color=\"inherit\"\n                onClick={handleClose}\n            >\n                <CloseIcon />\n            </IconButton>,\n        ]}\n    />);\n}\n\nexport const SnackbarError: React.FC<SnackbarAppProps> = (props) => (\n    <SnackbarApp type='error' {...props}/>\n); \n\nexport const SnackbarInfo: React.FC<SnackbarAppProps> = (props) => (\n    <SnackbarApp type='info' {...props}/>\n); \n","import * as React from \"react\";\nimport FileCopy from '@material-ui/icons/FileCopy';\nimport { ExportDataSet } from \"../api\";\nimport Card from \"@material-ui/core/Card\";\nimport Link from \"@material-ui/core/Link\";\nimport CardContent from \"@material-ui/core/CardContent\";\nimport CardActions from \"@material-ui/core/CardActions\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport Typography from \"@material-ui/core/Typography\";\nimport CardHeader from \"@material-ui/core/CardHeader\";\nimport DownloadIcon from '@material-ui/icons/SaveAlt';\nimport { SnackbarInfo } from \"./snackbars\";\nimport { LocalizationApi } from \"../services\";\nimport OpenInNew from '@material-ui/icons/OpenInNew';\nimport Divider from \"@material-ui/core/Divider\";\n\ninterface ExportCardProps {\n    fileName: string;\n    dataToExport: ExportDataSet;\n    loc: LocalizationApi;\n}\n\nfunction download(fileName: string) {\n    return `${fileName}-${new Date().toLocaleDateString()}.json`;\n}\n\nexport const ExportCard: React.FC<ExportCardProps> = (props) => {\n    const [info, setInfo] = React.useState<string>();\n    const [json, setJson] = React.useState<string>();\n\n    const {loc} = props;\n\n    const url = React.useMemo(() => {\n        if (json) {\n            const blob = new Blob([json], { type: 'application/octet-stream' });\n            return URL.createObjectURL(blob);\n        } else {\n            return '#';\n        }\n    }, [json]);\n\n    React.useEffect(() => {\n        setJson(JSON.stringify(props.dataToExport));\n    }, [props.dataToExport]);\n\n    async function handleCopy() {\n        if (json) {\n            navigator.clipboard.writeText(json);\n            setInfo(loc.get('Copied to clipboard'));\n        }\n    }\n\n    return <Card>\n        <CardHeader title={loc.get('Migrate your data')} />\n        {info && <SnackbarInfo message={info} />}\n        <CardContent>\n            {!json && info && <Typography color='error'>{info}</Typography>}\n            {json && <Content \n                fileName={props.fileName} \n                url={url}\n                description={loc.get('Download JSON file')}\n                extra={loc.get('Import it later from the other domain')}\n                />\n            }\n        </CardContent>\n        {json && <CardActions>\n            <IconButton\n                color='primary'\n                disabled={!json}\n                href={url}\n                download={download(props.fileName)}>\n                <DownloadIcon />\n            </IconButton>\n            <IconButton\n                disabled={!json}\n                key='export-copy-to-clipboard'\n                aria-label={loc.get('Copy JSON')}\n                onClick={handleCopy} >\n                <FileCopy />\n            </IconButton>\n        </CardActions>}\n    </Card>;\n}\n\ninterface ContentProps { \n    fileName: string;\n    url: string; \n    description: string;\n    extra: string;\n};\n\nconst Content: React.FC<ContentProps> = (props) => (\n    <React.Fragment>\n        <Typography variant='body1'>\n            1. {props.description}\n            : <Link href={props.url} \n            download={download(props.fileName)} \n            variant='body1'>\n            {`${props.fileName}.json`}\n            </Link>.\n        </Typography>\n        <Divider style={{marginTop: '2rem', marginBottom: '2rem', }}/>\n        <Typography variant='subtitle1'>\n        2. <Link href='https://btapp.netlify.com/import-export' target='_blank'>\n                {props.extra} <OpenInNew style={{width: '0.8rem', verticalAlign: 'middle'}}/>\n            </Link>.\n        </Typography>\n    </React.Fragment>\n);","import React from 'react';\nimport { Header } from \"./components/Header\";\nimport Container from \"@material-ui/core/Container\";\nimport Box from \"@material-ui/core/Box\";\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport { BudgetTracker, ExportDataSet } from './api';\nimport { ExportCard } from './components/ExportCard';\nimport { Typography, Link } from '@material-ui/core';\nimport OpenInNew from '@material-ui/icons/OpenInNew';\n\nconst App: React.FC<{ btApp: BudgetTracker }> = (props) => {\n\n    const [exportData, setExportData] = React.useState<ExportDataSet>();\n    const loc = props.btApp.localization;\n\n    React.useEffect(() => {\n        async function initExportData() {\n            try {\n                const store = await props.btApp.getBudgetsStore();\n                setExportData(await store.export());\n            } catch (error) {\n                console.warn('There is no data to export: ', error);\n                setExportData(undefined);\n            }\n        }\n        initExportData();\n\n    }, [props.btApp]);\n\n    return (<React.Fragment>\n        <CssBaseline />\n        <Header title={loc.get('App moved')} actions={[]} />\n        <main>\n            <Container maxWidth='lg'>\n                <Box mt={2} marginBottom={8}>\n                    <Typography variant='subtitle1' color='error'>\n                    {loc.get('App moved title')}: <Link href='https://btapp.netlify.com' target='_blank'>btapp.netlify.com<OpenInNew style={{width: '0.8rem', verticalAlign: 'middle'}}/>\n                    </Link></Typography>\n\n                    {exportData && <ExportCard loc={props.btApp.localization} dataToExport={exportData} fileName='budget-tracker-exported-data' />}\n\n                    <Typography variant='subtitle1' color='error'>\n                    {loc.get('App moved title')}: <Link href='https://btapp.netlify.com' target='_blank'>btapp.netlify.com<OpenInNew style={{width: '0.8rem', verticalAlign: 'middle'}}/>\n                    </Link></Typography>.\n                </Box>\n            </Container>\n        </main>\n    </React.Fragment>);\n}\n\nexport default App;\n","\nimport { SubStorageApi } from \"./StorageApi\";\n\nexport class DataSync {\n\n    private readonly from: SubStorageApi;\n    private readonly to: SubStorageApi;\n    private readonly name: string;\n\n    // Creator should pass the correct storage depending on the action\n    constructor(from: SubStorageApi, to: SubStorageApi) {\n        this.from = from;\n        this.to = to;\n        this.name = `${this.from.constructor.name} > ${this.to.constructor.name}`;\n    }\n\n    async sync() {\n        // TODO implement a synchronization mechanism **to get only the pending changes**\n        // For now we are reading all the data from firestore, which is far to be optimal\n        // Saving synched device IDs per document would work if we could check that array does not\n        // contains current device ID, \"array not contains\" feature is not supported by firestore\n        console.debug(this.name);\n        const pending = await this.from.export();\n        if (pending) {\n            return this.to.import(pending);\n        }\n        console.info('Nothing to sync');\n    }\n}\n","import { SubStorageApi, AppStorageApi, StorageObserver } from \"./StorageApi\";\nimport { Budget, Expense, Category } from \"../../api\";\nimport { DataSync } from \"./DataSync\";\nimport { uuid } from \"../../domain/utils/uuid\";\n\nexport class AppStorageManager implements AppStorageApi {\n    private local: SubStorageApi;\n    private remote?: SubStorageApi;\n    private observers: Set<StorageObserver>;\n\n    constructor (local: SubStorageApi) {\n        console.log('Instantiated', this);\n        this.local = local;\n        this.observers = new Set();\n    }\n\n    addObserver(observer: StorageObserver) {\n        this.observers.add(observer);\n    }\n\n    deleteObserver(observer: StorageObserver) {\n        this.observers.delete(observer);\n    }\n\n    private notifyObservers () {\n        this.observers.forEach(o=>o.onStorageDataChanged());\n    }\n    \n    private loadDeviceId () {\n        const key = 'deviceId';\n        const deviceId = localStorage.getItem(key);\n        if (deviceId) {\n            return deviceId;\n        } else {\n            console.debug('First time app starts, generating device ID');\n            const deviceId = uuid();\n            localStorage.setItem(key, deviceId)\n            return deviceId;\n        }\n    }\n\n    async setRemote (remote?: SubStorageApi) {\n        if (this.remote !== remote) {\n            this.remote = remote;\n            if (this.remote) {\n                return this.sync();\n            }\n        }\n    }\n\n    async sync () {\n        if (this.remote) {\n            const [\n                remoteTime, \n                localTime\n            ] = await Promise.all([\n                this.remote.getLastTimeSaved(), \n                this.local.getLastTimeSaved()\n            ]);\n            \n            if (remoteTime > localTime) {\n                await new DataSync(this.remote, this.local).sync();\n            } else if (remoteTime < localTime) {\n                await new DataSync(this.local, this.remote).sync();\n            } else {\n                console.debug('Nothing to sync');\n                return;\n            }\n            this.notifyObservers();\n            console.debug('Sync done');\n        }\n    }\n\n    async getBudget(budgetId: string) {\n        return this.local.getBudget(budgetId);\n    }\n\n    async getBudgets() {\n        return this.local.getBudgets();\n    }\n\n    async getExpenses(budgetId: string) {\n        return this.local.getExpenses(budgetId);\n    }\n    \n    async setBudget(budget: Budget, timestamp = Date.now()) {\n        const localPromise = this.local.setBudget(budget, timestamp);\n        if (this.remote) {\n            this.remote.setBudget(budget, timestamp);\n        }\n        return localPromise;\n    }\n    \n    async deleteBudget(budgetId: string, timestamp = Date.now()) {\n        const localPromise = this.local.deleteBudget(budgetId, timestamp);\n        if (this.remote) {\n            this.remote.deleteBudget(budgetId, timestamp);\n        }\n        return localPromise;\n    }\n\n    async getExpense(expenseId: string) {\n        return this.local.getExpense(expenseId);\n    }\n    \n    async setExpenses(expenses: Expense[], timestamp = Date.now()) {\n        const localPromise = this.local.setExpenses(expenses, timestamp);\n        if (this.remote) {\n            this.remote.setExpenses(expenses, timestamp);\n        }\n        return localPromise;\n    }\n\n    async deleteExpense(expenseId: string, timestamp = Date.now()) {\n        const localPromise = this.local.deleteExpense(expenseId, timestamp);\n        if (this.remote) {\n            this.remote.deleteExpense(expenseId, timestamp);\n        }\n        return localPromise;\n    }\n\n    async getCategory(categoryId: string) {\n        return this.local.getCategory(categoryId);\n    }\n\n    async getCategories() {\n        return this.local.getCategories();\n    }\n\n    async setCategories(categories: Category[], timestamp = Date.now()) {\n        const localPromise = this.local.setCategories(categories, timestamp);\n        if (this.remote) {\n            this.remote.setCategories(categories, timestamp);\n        }\n        return localPromise;\n    }\n\n    async deleteCategory(identifier: string, timestamp = Date.now()) {\n        const localPromise = this.local.deleteCategory(identifier, timestamp);\n        if (this.remote) {\n            this.remote.deleteCategory(identifier, timestamp);\n        }\n        return localPromise;\n    }\n}\n","import { AppStorageApi } from './services/storage/StorageApi';\nimport { AuthApi } from './services/AuthApi';\nimport { BudgetsStore, CategoriesStore, IconsStore, CurrenciesStore, CountriesStore } from './domain/stores/interfaces';\nimport { LocalizationApi } from './services';\n\n\nexport interface Budget {\n    identifier: string;\n    name: string;\n    total: number;\n    currency: string;\n    /** Timestamp for starting date */\n    from: number;\n    /** Timestamp for ending date */\n    to: number;\n}\n\nexport interface Expense {\n    amount: number;\n    amountBaseCurrency: number;\n    currency: string;\n    categoryId: string;\n    countryCode: string;\n    description?: string;\n    identifier: string;\n    /** Timestamp when the expense applies */\n    when: number;\n    budgetId: string;\n    splitInDays: number;\n}\n\nexport interface ObjectMap<T> {\n    [k: string]: T   \n}\n\nexport interface ExpensesMap extends ObjectMap<Expense> {}\n\nexport interface BudgetsMap extends ObjectMap<Budget> {}\n\nexport interface CurrencyRates {\n    readonly base: string;\n    readonly rates: ObjectMap<number>;\n    readonly date: Date;\n}\n\nexport interface Category {\n    identifier: string;\n    name: string;\n    icon: string;\n}\n\nexport interface CategoriesMap extends ObjectMap<Category> {}\n\nexport interface YMD {\n    year: number,\n    month: number,\n    day: number\n}\n\nexport interface CountryEntry {\n    code: string;\n    name: string;\n}\n\nexport interface User {\n    timestamp: number;\n}\n\nexport interface ExportDataSet {\n    budgets: BudgetsMap;\n    categories: CategoriesMap;\n    expenses: ExpensesMap;\n    lastTimeSaved: number;\n}\n\nexport enum SyncDirection {\n    RemoteToLocal = 'RemoteToLocal', LocalToRemote = 'LocalToRemote'\n}\n\nexport enum EntityNames {\n    Budgets = 'budgets',\n    Expenses = 'expenses',\n    Categories = 'categories',\n}\n\nexport interface Exporter {\n    export(): Promise<ExportDataSet>;\n}\n\nexport interface Importer {\n    import(data: ExportDataSet): Promise<void>;\n}\n\nexport interface BudgetTracker {\n\n    readonly storage: AppStorageApi;\n    readonly localization: LocalizationApi;\n    \n    getAuth (): Promise<AuthApi>;\n    getBudgetsStore(): Promise<BudgetsStore>;\n    getCategoriesStore(): Promise<CategoriesStore>\n    getIconsStore(): Promise<IconsStore>;\n    getCurrenciesStore(): Promise<CurrenciesStore>;\n    getCountriesStore (): Promise<CountriesStore>;\n}\n","import nanoid from 'nanoid';\n\nexport function uuid() {\n    return nanoid();\n}\n","import { DbItem, SubStorageApi } from \"./StorageApi\";\nimport { openDB, IDBPDatabase, DBSchema } from 'idb';\nimport { Budget, Category, Expense, BudgetsMap, ExpensesMap, CategoriesMap, ExportDataSet, EntityNames } from \"../../api\";\n\ninterface ExpenseDb extends Expense, DbItem { }\ninterface BudgetDb extends Budget, DbItem { }\ninterface CategoryDb extends Category, DbItem { }\n\nconst keyPath = { keyPath: 'identifier' };\n\ninterface Schema extends DBSchema {\n    [EntityNames.Budgets]: {\n        key: string,\n        value: BudgetDb,\n        indexes: { 'deleted, to': string },\n    },\n    [EntityNames.Categories]: {\n        value: CategoryDb,\n        key: string,\n        indexes: { 'deleted, name': string },\n    },\n    [EntityNames.Expenses]: {\n        value: ExpenseDb,\n        key: string,\n        indexes: { 'deleted, budgetId, when': [number, string, number] },\n    }\n}\n\nexport class IndexedDb implements SubStorageApi {\n    private readonly name = 'budgetTrackerDb';\n    private readonly version = 1;\n    private _db?: IDBPDatabase<Schema>;\n\n    private async createDb() {\n        return openDB<Schema>(this.name, this.version, {\n            upgrade(db) {\n                const budgetsStore = db.createObjectStore(EntityNames.Budgets, keyPath);\n                budgetsStore.createIndex('deleted, to', ['deleted', 'to']);\n\n                const categoriesStore = db.createObjectStore(EntityNames.Categories, keyPath);\n                categoriesStore.createIndex('deleted, name', ['deleted', 'name']);\n\n                const expensesStore = db.createObjectStore(EntityNames.Expenses, keyPath);\n                expensesStore.createIndex('deleted, budgetId, when', ['deleted', 'budgetId', 'when']);\n            },\n        });\n    }\n\n    private async enablePersistentStorage(){\n        const {storage} = navigator;\n        const persistent = storage && storage.persist && await storage.persist();\n        if (persistent) {\n            console.info(\"Storage will not be cleared except by explicit user action\");\n        } else {\n            console.warn(\"Storage may be cleared by the UA under storage pressure.\")\n        }\n    }\n\n    async getDb() {\n        if (this._db === undefined) {\n            await this.enablePersistentStorage();\n            this._db = await this.createDb();\n        }\n        return this._db;\n    }\n\n    async getBudgets(): Promise<BudgetsMap> {\n        const db = await this.getDb();\n        const bound = IDBKeyRange.upperBound([1, 0]);\n        const budgetsResult = await db.getAllFromIndex(\n            EntityNames.Budgets,\n            'deleted, to',\n            bound\n        );\n        const budgetMap: BudgetsMap = {}; \n        budgetsResult.forEach(b => budgetMap[b.identifier] = b);\n        return budgetMap;\n    }\n\n    async getBudget(identifier: string) {\n        const db = await this.getDb();\n        return db.get(EntityNames.Budgets, identifier);\n    }\n\n    async setBudget(budget: Budget, timestamp: number) {\n        const db = await this.getDb();\n        await db.put(\n            EntityNames.Budgets,\n            {\n                deleted: 0,\n                timestamp,\n                ...budget\n            });\n        return this.setLastTimeSaved(timestamp);\n    }\n\n    async deleteBudget(budgetId: string, timestamp = Date.now()) {\n        const db = await this.getDb();\n        const tx = db.transaction(EntityNames.Budgets, 'readwrite');\n        const budget = await tx.store.get(budgetId);\n        if (budget) {\n            tx.store.put({\n                ...budget,\n                deleted: 1,\n                timestamp,\n            });\n        }\n        await tx.done;\n        this.setLastTimeSaved(timestamp);\n    }\n\n    async getExpenses(budgetId: string): Promise<ExpensesMap> {\n        const db = await this.getDb();\n        const budget = await db.get(EntityNames.Budgets, budgetId);\n        if (budget) {\n            const bound = IDBKeyRange.bound(\n                [0, budgetId, budget.from],\n                [0, budgetId, budget.to]);\n            const expensesResult = await db.getAllFromIndex(\n                EntityNames.Expenses,\n                'deleted, budgetId, when',\n                bound\n            );\n            const expenses: ExpensesMap = {};\n            expensesResult.forEach(e => expenses[e.identifier] = e);\n            return expenses;\n        }\n        throw new Error('There is no budget with id ' + budgetId);\n    }\n\n    private async getAllExpenses(): Promise<ExpensesMap> {\n        const db = await this.getDb();\n        const expenses = await db.getAll(EntityNames.Expenses);\n        const expensesMap: ExpensesMap = {};\n        expenses.forEach(e => expensesMap[e.identifier] = e);\n        return expensesMap;\n    }\n\n    async getExpense(expenseId: string) {\n        const db = await this.getDb();\n        return db.get(EntityNames.Expenses, expenseId);\n    }\n\n    async setExpenses(expenses: Expense[], timestamp: number) {\n        const db = await this.getDb();\n        const tx = db.transaction(EntityNames.Expenses, 'readwrite');\n        for (const expense of expenses) {\n            tx.store.put({\n                ...expense,\n                timestamp,\n                deleted: 0\n            });\n        }\n        await tx.done;\n        return this.setLastTimeSaved(timestamp);\n    }\n\n    async deleteExpense(expenseId: string, timestamp: number) {\n        const db = await this.getDb();\n        const tx = db.transaction(EntityNames.Expenses, 'readwrite');\n        const expense = await tx.store.get(expenseId);\n        if (expense) {\n            tx.store.put({ ...expense, deleted: 1, timestamp });\n        }\n        await tx.done;\n        return this.setLastTimeSaved(timestamp);\n    }\n\n    async getCategories(): Promise<CategoriesMap> {\n        const db = await this.getDb();\n        const bound = IDBKeyRange.upperBound([1,], true);\n        const categoriesResult = await db.getAllFromIndex(\n            EntityNames.Categories,\n            'deleted, name',\n            bound);\n        const categories: CategoriesMap = {};\n        if (categoriesResult) {\n            categoriesResult.forEach(c => categories[c.identifier] = c);\n        }\n        return categories;\n    }\n\n    async setCategories(categories: Category[], timestamp: number) {\n        const db = await this.getDb();\n        const tx = db.transaction(EntityNames.Categories, 'readwrite');\n        for (const category of categories) {\n            tx.store.put({\n                ...category,\n                timestamp,\n                deleted: 0\n            });\n        }\n        await tx.done;\n        return this.setLastTimeSaved(timestamp);\n    }\n\n    async getCategory(identifier: string) {\n        const db = await this.getDb();\n        return db.get(EntityNames.Categories, identifier);\n    }\n\n    async deleteCategory(identifier: string, timestamp: number) {\n        const db = await this.getDb();\n        const tx = db.transaction(EntityNames.Categories, 'readwrite');\n        const category = await tx.store.get(identifier);\n        if (category) {\n            tx.objectStore(EntityNames.Categories).put({ ...category, timestamp, deleted: 1 });\n        }\n        await tx.done;\n        return this.setLastTimeSaved(timestamp);\n    }\n\n    async import(data: ExportDataSet) {\n        const db = await this.getDb();\n        const tx = db.transaction(\n            [EntityNames.Budgets, EntityNames.Categories, EntityNames.Expenses],\n            'readwrite');\n\n        const dbProps: DbItem = {\n            deleted: 0,\n            timestamp: data.lastTimeSaved\n        };\n\n        for (const budgetId in data.budgets) {\n            tx.objectStore(EntityNames.Budgets).put(\n                { ...dbProps, ...data.budgets[budgetId] });\n        }\n        for (const expenseId in data.expenses) {\n            tx.objectStore(EntityNames.Expenses)\n                .put({ ...dbProps, ...data.expenses[expenseId] });\n        }\n        for (const categoryId in data.categories) {\n            tx.objectStore(EntityNames.Categories).put(\n                { ...dbProps, ...data.categories[categoryId] });\n        }\n        await tx.done;\n        return this.setLastTimeSaved(data.lastTimeSaved);\n    }\n\n    async export(): Promise<ExportDataSet> {\n        const [budgets, categories, expenses, lastTimeSaved] = await Promise.all([\n            this.getBudgets(),\n            this.getCategories(),\n            this.getAllExpenses(),\n            this.getLastTimeSaved()\n        ]);\n        return {\n            budgets,\n            expenses,\n            categories,\n            lastTimeSaved\n        };\n    }\n\n    async getLastTimeSaved(): Promise<number> {\n        return parseInt(localStorage.getItem('timestamp') || '0');\n    }\n    async setLastTimeSaved(timestamp: number): Promise<void> {\n        localStorage.setItem('timestamp', timestamp.toString());\n    }\n}\n","import { ObjectMap } from '../api';\nimport { LocalizationApi } from '.';\n\nconst DEFAULT_LANG = 'en';\n\nconst LANG_STRINGS: ObjectMap<Promise<any>> = {\n    [DEFAULT_LANG]: import('../constants/strings/en.json'),\n    'es': import('../constants/strings/es.json'),\n};\n\nexport class LocalizationImpl implements LocalizationApi {\n\n    readonly lang: string;\n    private strings: ObjectMap<string>;\n\n    constructor(lang: string) {\n        lang = lang.slice(0, 2);\n\n        this.lang = lang in LANG_STRINGS ? lang : DEFAULT_LANG;\n        this.strings = {};\n        this.initStrings();\n    }\n\n    private async initStrings() {\n        const loaded = (await LANG_STRINGS[this.lang]).default;\n        Object.entries(loaded).forEach(([k, v]) => this.strings[k] = v as string);\n    }\n\n    get(key: string) {\n        return this.strings[key] || key;\n    }\n}\n","\nimport * as serviceWorker from './serviceWorker';\nimport ReactDOM from 'react-dom';\nimport React from 'react';\nimport App from './App';\nimport { BudgetTrackerImpl } from './BudgetTrackerImpl';\n\nconst btApp = new BudgetTrackerImpl();\n\nReactDOM.render(<App btApp={btApp}/>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n","import { SubStorageApi, AppStorageApi } from './services/storage/StorageApi';\nimport { \n    CategoriesStore, BudgetsStore, \n    IconsStore, CurrenciesStore, \n    CountriesStore} from './domain/stores/interfaces';\nimport { AuthApi } from './services/AuthApi';\nimport { AppStorageManager } from './services/storage/AppStorageManager';\nimport { IndexedDb } from './services/storage/IndexedDb';\nimport { BudgetTracker } from './api';\nimport { LocalizationApi } from './services';\nimport { LocalizationImpl } from './services/LocalizationStoreImpl';\n\nexport class BudgetTrackerImpl implements BudgetTracker {\n\n    readonly storage: AppStorageApi;\n    readonly localization: LocalizationApi;\n    private _firestore?: SubStorageApi;\n    private _auth?: AuthApi;\n    private _authPromise?: Promise<AuthApi>;\n    private _budgetsStore?: BudgetsStore;\n    private _categoriesStore?: CategoriesStore;\n    private _iconsStore?: IconsStore;\n    private _currenciesStore?: CurrenciesStore;\n    private _countriesStore?: CountriesStore;\n\n    constructor () {\n        // background initialization for auth\n        this.initBgAuth();\n        this.storage = new AppStorageManager(new IndexedDb());\n        this.localization = new LocalizationImpl(navigator.language);\n    }\n\n    private async initBgAuth () {\n        console.debug('Fetching auth info...');\n        console.debug('Auth: ', await (await this.getAuth()).getUserId());\n    }\n\n    private async initFirestore (uid?: string) {\n        if (uid) {\n            if (!this._firestore) {\n                try {\n                    const storage  = await import('./services/storage/FirestoreApi');\n                    this._firestore = new storage.FirestoreApi(uid, true);\n                } catch (error) {\n                    console.warn('Cannot get user ID: ', error);\n                }\n            }\n        } else {\n            this._firestore = undefined;\n        }\n        return this._firestore;\n    }\n\n    private onAuth = async (uid?: string) => {\n        this.storage.setRemote(await this.initFirestore(uid));\n    }\n\n    async getAuth () {\n        if (this._auth) {\n            return this._auth;\n        }\n        if (this._authPromise) {\n            return this._authPromise;\n        }\n        this._authPromise = this.getAuthPromise();\n        this._auth = await this._authPromise;\n        this._auth.subscribe(this.onAuth);\n        this._authPromise = undefined;\n        return this._auth;\n    }\n\n    private async getAuthPromise () {\n        const auth  = await import('./services/AuthApiImpl');\n        return new auth.AuthApiImpl();\n    }\n\n    async getBudgetsStore (): Promise<BudgetsStore> {\n        if (!this._budgetsStore) {\n            const bs = await import('./domain/stores/BudgetsStoreImpl');\n            this._budgetsStore = new bs.BudgetsStoreImpl(this);\n        }\n        return this._budgetsStore;\n    }\n\n    async getCategoriesStore () {\n        if (!this._categoriesStore) {\n            const imported = await import('./domain/stores/CategoriesStoreImpl');\n            this._categoriesStore = new imported.CategoriesStoreImpl(this.storage);\n        }\n        return this._categoriesStore;\n    }\n\n    async getIconsStore () {\n        if (!this._iconsStore) {\n            const imported  = await import('./domain/stores/IconsStoreImpl');\n            this._iconsStore = new imported.IconsStoreImpl();\n        }\n        return this._iconsStore;\n    }\n\n    async getCurrenciesStore () {\n        if (!this._currenciesStore) {\n            const [currencies, imported] = await Promise.all([\n                import('./constants/currencies.json'),\n                import('./domain/stores/CurrenciesStoreImpl')\n            ]);\n            this._currenciesStore = new imported.CurrenciesStoreImpl(currencies.default);\n        }\n        return this._currenciesStore;\n    }\n\n    async getCountriesStore () {\n        if (!this._countriesStore) {\n            const imported  = await import('./domain/stores/CountriesStoreImpl');\n            this._countriesStore = new imported.CountriesStoreImpl(\n                await import('./constants/countries.json'));\n        }\n        return this._countriesStore;\n    }\n}\n"],"sourceRoot":""}