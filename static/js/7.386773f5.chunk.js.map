{"version":3,"sources":["services/RemoteApi.ts","services/GeoApi.ts","domain/stores/CountriesStoreImpl.ts"],"names":["RemoteApi","baseUrl","this","path","queryParams","url","URL","Object","keys","forEach","key","searchParams","append","toString","request","fetch","response","ok","json","Error","status","params","getUrl","method","GeoApi","api","navigator","geolocation","Promise","resolve","reject","getCurrentPosition","lat","lon","format","get","getCurrentLocation","pos","getCountry","coords","latitude","longitude","resp","address","country_code","CountriesStoreImpl","countries","geoApi","currentCountry","LAST_COUNTRY_KEY","values","getCachedCurrentCountry","cachedString","localStorage","getItem","cachedInfo","JSON","parse","code","error","console","warn","countryCode","toUpperCase","timestamp","Date","now","setItem","stringify","fetchCurrentCountry","getCurrentCountry","setCurrentCountry"],"mappings":"qMAEaA,EAAb,WAGI,WAAYC,GAAkB,yBAFrBA,aAEoB,EACzBC,KAAKD,QAAUA,EAJvB,mDAOoBE,EAAcC,GAC1B,IAAMC,EAAM,IAAIC,IAAJ,UAAWJ,KAAKD,QAAhB,YAA2BE,IAKvC,OAJAI,OACKC,KAAKJ,GACLK,SACG,SAAAC,GAAG,OAAIL,EAAIM,aAAaC,OAAOF,EAAKN,EAAYM,OACjDL,EAAIQ,aAbnB,qLAiB2BR,EAAaS,GAjBxC,uFAkB+BC,MAAMV,EAAKS,GAlB1C,YAkBcE,EAlBd,QAmBqBC,GAnBrB,yCAoBmBD,EAASE,QApB5B,aAsBc,IAAIC,MAAJ,yBAA4Bd,EAA5B,cAAqCW,EAASI,SAtB5D,wKAyBiBjB,EAAckB,GAzB/B,8EA0BchB,EAAMH,KAAKoB,OAAOnB,EAAMkB,GA1BtC,kBA2BenB,KAAKa,MAAMV,EAAK,CAACkB,OAAQ,SA3BxC,iH,4FCAaC,EAAb,iDAEqBC,IAAM,IAAIzB,IAAU,uCAFzC,+KAKY0B,UAAUC,YALtB,yCAMmB,IAAIC,SAAkB,SAACC,EAASC,GACnCJ,UAAUC,YAAYI,mBAAmBF,EAASC,OAPlE,gCAUeF,QAAQE,OAAO,iCAV9B,2KAaqBE,EAAaC,GAblC,8EAccZ,EAAS,CACXa,OAAQ,OACRD,IAAKA,EAAIpB,WACTmB,IAAKA,EAAInB,YAjBrB,kBAmBeX,KAAKuB,IAAIU,IACZ,cAAed,IApB3B,qRAyB0BnB,KAAKkC,qBAzB/B,cAyBcC,EAzBd,gBA0B2BnC,KAAKoC,WAAWD,EAAIE,OAAOC,SAAUH,EAAIE,OAAOE,WA1B3E,cA0BcC,EA1Bd,yBA2BeA,EAAKC,QAAQC,cA3B5B,6G,mDCOO,IAAMC,EAAb,WAOI,WAAYC,GAA4B,yBALvBC,YAKsB,OAJ/BC,oBAI+B,OAHtBC,iBAAmB,cAGG,KAF9BH,eAE8B,EACnC5C,KAAK4C,UAAYvC,OAAO2C,OAAOJ,GAC/B5C,KAAK6C,OAAS,IAAIvB,EAClBtB,KAAK8C,eAAiB9C,KAAKiD,0BAVnC,sEAcQ,IAAMC,EAAeC,aAAaC,QAAQpD,KAAK+C,kBAC/C,GAAIG,EACA,IACI,IAAMG,EAAaC,KAAKC,MAAML,GAC9B,GAAIG,EAAWG,KACX,OAAOH,EAEb,MAAOI,GACLC,QAAQC,KAAKF,MAtB7B,wCA4B+BG,GACvB5D,KAAK8C,eAAiB,CAClBU,KAAMI,EAAYC,cAClBC,UAAWC,KAAKC,OAEpBb,aAAac,QACTjE,KAAK+C,iBACLO,KAAKY,UAAUlE,KAAK8C,mBAnChC,yJA2CY9C,KAAK8C,gBACL9C,KAAK8C,eAAeU,MACpBxD,KAAK8C,eAAegB,WACpBC,KAAKC,MAAQhE,KAAK8C,eAAegB,UAAY,MA9CzD,yCA+CmB9D,KAAK8C,eAAeU,MA/CvC,gCAiDexD,KAAKmE,uBAjDpB,2RAsDsCnE,KAAK6C,OAAOuB,oBAtDlD,YAsDkBR,EAtDlB,+BAwDgB5D,KAAKqE,kBAAkBT,GAxDvC,kBAyDuBA,EAAYC,eAzDnC,uDA4DYH,QAAQC,KAAK,mCAAb,MA5DZ,iCA8De3D,KAAK8C,gBAAkB9C,KAAK8C,eAAeU,MA9D1D,wJAuCQ,OAAOxD,KAAK8C,gBAAkB9C,KAAK8C,eAAeU,SAvC1D","file":"static/js/7.386773f5.chunk.js","sourcesContent":["import { ObjectMap } from \"../api\";\n\nexport class RemoteApi {\n    readonly baseUrl: string;\n\n    constructor(baseUrl: string) {\n        this.baseUrl = baseUrl;\n    }\n\n    private getUrl (path: string, queryParams: ObjectMap<string>) {\n        const url = new URL(`${this.baseUrl}/${path}`);\n        Object\n            .keys(queryParams)\n            .forEach(\n                key => url.searchParams.append(key, queryParams[key]));\n        return url.toString();\n\n    }\n\n    private async fetch<T>(url: string, request?: RequestInit): Promise<T> {\n        const response = await fetch(url, request);\n        if (response.ok) {\n            return response.json();\n        }\n        throw new Error(`Error fetching ${url} > ${response.status}`);\n    }\n\n    async get<T>(path: string, params: ObjectMap<string>): Promise<T> {\n        const url = this.getUrl(path, params)\n        return this.fetch(url, {method: 'GET' });\n    }\n}","import { RemoteApi } from \"./RemoteApi\";\n\nexport class GeoApi {\n\n    private readonly api = new RemoteApi('https://nominatim.openstreetmap.org');\n\n    async getCurrentLocation () {\n        if (navigator.geolocation) {\n            return new Promise<Position>((resolve, reject) => {\n                navigator.geolocation.getCurrentPosition(resolve, reject);\n            });\n        }\n        return Promise.reject('Geolocation is not supported');\n    }\n\n    async getCountry(lat: number, lon: number){\n        const params = {\n            format: 'json',\n            lon: lon.toString(),\n            lat: lat.toString(),\n        };\n        return this.api.get<{address: {country_code: string}}>(\n            'reverse.php', params\n        );\n    }\n\n    async getCurrentCountry () {\n        const pos = await this.getCurrentLocation();\n        const resp = await this.getCountry(pos.coords.latitude, pos.coords.longitude);\n        return resp.address.country_code;\n    }\n}\n","import { GeoApi } from '../../services/GeoApi';\nimport { CountryEntry } from '../../api';\nimport { CountriesStore } from './interfaces';\n\ninterface CachedCountry {\n    code: string;\n    timestamp?: number;\n}\n\nexport class CountriesStoreImpl implements CountriesStore {\n\n    private readonly geoApi: GeoApi;\n    private currentCountry?: CachedCountry;\n    private readonly LAST_COUNTRY_KEY = 'lastCountry';\n    readonly countries: CountryEntry[];\n\n    constructor(countries: CountryEntry[]) {\n        this.countries = Object.values(countries);\n        this.geoApi = new GeoApi();\n        this.currentCountry = this.getCachedCurrentCountry();\n    }\n\n    private getCachedCurrentCountry (): CachedCountry|undefined {\n        const cachedString = localStorage.getItem(this.LAST_COUNTRY_KEY);\n        if (cachedString) {\n            try {\n                const cachedInfo = JSON.parse(cachedString);\n                if (cachedInfo.code) {\n                    return cachedInfo;\n                }     \n            } catch (error) {\n                console.warn(error);\n            }\n        }\n        return undefined;\n    }\n\n    private setCurrentCountry (countryCode: string) {\n        this.currentCountry = { \n            code: countryCode.toUpperCase(),\n            timestamp: Date.now()\n        }\n        localStorage.setItem(\n            this.LAST_COUNTRY_KEY, \n            JSON.stringify(this.currentCountry));\n    }\n\n    get currentCountryCode () {\n        return this.currentCountry && this.currentCountry.code;\n    }\n\n    async getCurrentCountry () {\n        if (this.currentCountry && \n            this.currentCountry.code && \n            this.currentCountry.timestamp &&\n            Date.now() - this.currentCountry.timestamp < 3600000) {\n            return this.currentCountry.code;\n        }\n        return this.fetchCurrentCountry();\n    }\n\n    private async fetchCurrentCountry () {\n        try {\n            const countryCode = await this.geoApi.getCurrentCountry();\n            if (countryCode) {\n                this.setCurrentCountry(countryCode);\n                return countryCode.toUpperCase();\n            }\n        } catch (error) {\n            console.warn('Fetching current country error: ', error);\n        }\n        return this.currentCountry && this.currentCountry.code;\n    }\n}\n"],"sourceRoot":""}