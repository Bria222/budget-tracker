{"version":3,"sources":["domain/utils/applyRate.ts","services/RemoteApi.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","services/CurrenciesApi.ts","domain/stores/CurrenciesStoreImpl.ts"],"names":["applyRate","amount","rate","RemoteApi","baseUrl","this","path","queryParams","url","URL","Object","keys","forEach","key","searchParams","append","toString","request","fetch","response","ok","json","Error","status","params","getUrl","method","_toConsumableArray","arr","Array","isArray","i","arr2","length","iter","Symbol","iterator","prototype","call","from","TypeError","currenciesApi","primary","_backup","baseCurrency","backup","get","base","targetCurrencies","target","join","apikey","process","availableCurrencies","expectedCurrencyMatch","getRatesPrimary","resp","console","warn","getRatesBackup","rates","undefined","CurrenciesStoreImpl","importedCurrencies","currencies","_rates","_timestamps","_countriesCurrencyMap","_lastCurrenciesUsed","Map","entries","getTimestampsFromDisk","getRatesFromDisk","currencyTo","promise","shouldFetch","fetchRates","isPresent","currency","getRate","isTimestampUpdated","timestamp","Date","now","UPDATE_RATES_MS","getRates","olRates","saveTimestampsToDisk","saveRatesToDisk","toCurrency","isUpdated","ratesStr","localStorage","getItem","KEY","JSON","parse","timestampsStr","KEY_TS","setItem","stringify","countryCode","cs","default","setLastCurrencyUsed","lastCurrenciesUsed","filter","c","KEY_LAST","slice","currenciesRead","parsed","error"],"mappings":"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","file":"static/js/5.4a1cc590.chunk.js","sourcesContent":["\nexport default function applyRate (amount: number, rate: number) {\n    return amount / rate;\n}\n","import { ObjectMap } from \"../api\";\n\nexport class RemoteApi {\n    readonly baseUrl: string;\n\n    constructor(baseUrl: string) {\n        this.baseUrl = baseUrl;\n    }\n\n    private getUrl (path: string, queryParams: ObjectMap<string>) {\n        const url = new URL(`${this.baseUrl}/${path}`);\n        Object\n            .keys(queryParams)\n            .forEach(\n                key => url.searchParams.append(key, queryParams[key]));\n        return url.toString();\n\n    }\n\n    private async fetch<T>(url: string, request?: RequestInit): Promise<T> {\n        const response = await fetch(url, request);\n        if (response.ok) {\n            return response.json();\n        }\n        throw new Error(`Error fetching ${url} > ${response.status}`);\n    }\n\n    async get<T>(path: string, params: ObjectMap<string>): Promise<T> {\n        const url = this.getUrl(path, params)\n        return this.fetch(url, {method: 'GET' });\n    }\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","import { CurrencyRates } from \"../api\";\nimport { RemoteApi } from \"./RemoteApi\";\n\nclass CurrenciesApi {\n\n    private readonly primary: RemoteApi;\n    private _backup?: RemoteApi;\n\n    constructor () {\n        this.primary = new RemoteApi('https://api.currencystack.io');\n    }\n\n    // most likely it won't be instantiated, that's why it is lazy loaded\n    private get backup () {\n        if (this._backup === undefined) {\n            this._backup = new RemoteApi('https://api.exchangeratesapi.io');\n        }\n        return this._backup;\n    }\n\n    private async getRatesBackup (baseCurrency: string) {\n        return this.backup.get<CurrencyRates>('latest', {base: baseCurrency});\n    }\n\n    private async getRatesPrimary (baseCurrency: string, targetCurrencies: Iterable<string>) {\n        return this.primary.get<CurrencyRates>('currency', \n            {\n                base: baseCurrency,\n                target: Array.from(targetCurrencies).join(','),\n                apikey: process.env.REACT_APP_CURRENCY_API_KEY || ''\n            });\n    }\n    \n    async getRates(baseCurrency: string, availableCurrencies: Iterable<string>, expectedCurrencyMatch?: string) {\n        let resp;\n        try {\n            resp = await this.getRatesPrimary(baseCurrency, availableCurrencies);\n        } catch (error) {\n            console.warn('Trying to fetch backup API: ', error);\n            resp = await this.getRatesBackup(baseCurrency);\n        } finally {\n            if (!resp) {\n                throw new Error(`There is no response for ${baseCurrency}`);\n            }\n            if (expectedCurrencyMatch && resp && !(expectedCurrencyMatch in resp.rates)) {\n                throw new Error(`There is no match for ${baseCurrency} => ${expectedCurrencyMatch}`);\n            }\n            if (Object.keys(resp.rates).length <= 0) {\n                throw new Error(`Empty response for ${baseCurrency}`);\n            }\n            return resp;\n        }\n    }\n}\n\nexport const currenciesApi = new CurrenciesApi();\n","import { CurrencyRates, ObjectMap } from \"../../api\";\nimport { currenciesApi } from \"../../services/CurrenciesApi\";\nimport { CurrenciesStore } from \"./interfaces\";\nimport applyRate from \"../utils/applyRate\";\n\nexport class CurrenciesStoreImpl implements CurrenciesStore {\n    static readonly KEY = 'currencyRates';\n    static readonly KEY_TS = 'currencyTimestamps';\n    static readonly KEY_LAST = 'lastCurrencies';\n    static readonly UPDATE_RATES_MS = 12 * 3600 * 1000;\n    \n    readonly currencies: Map<string, string>;\n    private _rates: ObjectMap<CurrencyRates>;\n    private _timestamps: ObjectMap<number>;\n    private _countriesCurrencyMap?: ObjectMap<string>;\n    private _lastCurrenciesUsed?: string[];\n\n    constructor(importedCurrencies: ObjectMap<string>) {\n        this.currencies = new Map(Object.entries(importedCurrencies));\n        this._timestamps = this.getTimestampsFromDisk();\n        this._rates = this.getRatesFromDisk();\n    }\n\n    /** \n     * @returns Currency exchange rate\n     * @throws Error when there is no rate for that pair of currencies\n     */\n    async getRate(baseCurrency: string, currencyTo: string): Promise<number> {\n        let promise = undefined;\n        if (this.shouldFetch(baseCurrency, currencyTo)) {\n            promise = this.fetchRates(baseCurrency, currencyTo);\n        }\n        if (promise && !this.isPresent(baseCurrency, currencyTo)) {\n            try {\n                await promise;\n            } catch (error) {\n                console.warn(error);\n            }\n        }\n        return this._rates[baseCurrency].rates[currencyTo];\n    }\n\n    getLocalRates(baseCurrency: string) {\n        return this._rates && this._rates[baseCurrency];\n    }\n\n    /** \n     * @returns Currency exchange rates for a base currency\n     */\n    async getRates(baseCurrency: string): Promise<CurrencyRates> {\n        let promise = undefined;\n        if (this.shouldFetch(baseCurrency)) {\n            promise = this.fetchRates(baseCurrency);\n        }\n        if (promise) {\n            try {\n                await promise;\n            } catch (error) {\n                console.warn(error);\n            }\n        }\n        return this._rates[baseCurrency];\n    }\n\n    /** \n     * @returns amount in base currency. \\ \n     * If baseCurrency == currency it returns the same input @param amount.\n     * It returns undefined if cannot get currency rate.\n     * @throws Error when there is no rate for that pair of currencies\n     */\n    async getAmountInBaseCurrency (baseCurrency: string, currency: string, amount: number) {\n        if (baseCurrency && currency !== baseCurrency) {\n            const rate = await this.getRate(baseCurrency, currency);\n            return applyRate(amount, rate);\n        }\n        return amount;\n    }\n\n    private isUpdated(baseCurrency: string) {\n        return baseCurrency in this._timestamps \n            && this.isTimestampUpdated(this._timestamps[baseCurrency]);\n    }\n\n    private isTimestampUpdated(timestamp: number) {\n        return Date.now() - timestamp <= CurrenciesStoreImpl.UPDATE_RATES_MS;\n    }\n\n    /** \n     * @throws Error when it returns invalid response after fetching currencies  \n     */\n    private async fetchRates(baseCurrency: string, expectedCurrencyMatch?: string) {\n        const rates = await currenciesApi.getRates(\n            baseCurrency, \n            this.currencies.keys(),\n            expectedCurrencyMatch);\n        if (Object.keys(rates.rates).length > 0) {\n            const olRates = this._rates[baseCurrency] || {};\n            this._rates[baseCurrency] = {...olRates, ...rates};\n            this._timestamps[baseCurrency] = Date.now()\n            this.saveTimestampsToDisk();\n            this.saveRatesToDisk();\n        }\n    }\n\n    private shouldFetch (baseCurrency: string, toCurrency?: string) {\n        return this._rates === undefined || \n            !(baseCurrency in this._rates) || \n            !this.isUpdated(baseCurrency) ||\n            (toCurrency && !this.isPresent(baseCurrency, toCurrency));\n    }\n\n    private isPresent(baseCurrency: string, toCurrency: string){\n        return this._rates && \n            baseCurrency in this._rates && \n            toCurrency in this._rates[baseCurrency].rates;\n    }\n\n    private getRatesFromDisk () {\n        const ratesStr = localStorage.getItem(CurrenciesStoreImpl.KEY);\n        if (ratesStr && ratesStr.length > 0) {\n            return JSON.parse(ratesStr);\n        }\n        return {};\n    }\n\n    private getTimestampsFromDisk () {\n        const timestampsStr = localStorage.getItem(CurrenciesStoreImpl.KEY_TS);\n        if (timestampsStr && timestampsStr.length > 0) {\n            return JSON.parse(timestampsStr);\n        }\n        return {};\n    }\n\n    private saveRatesToDisk () {\n        localStorage.setItem(CurrenciesStoreImpl.KEY, JSON.stringify(this._rates));\n    }\n\n    private saveTimestampsToDisk () {\n        localStorage.setItem(CurrenciesStoreImpl.KEY_TS, JSON.stringify(this._timestamps));\n    }\n\n    async getFromCountry (countryCode: string) {\n        if (!this._countriesCurrencyMap) {\n            const cs = await import('../../constants/countryCurrency.json');\n            this._countriesCurrencyMap = cs.default;    \n        }\n        const currency = this._countriesCurrencyMap[countryCode];\n        if (currency) {\n            this.setLastCurrencyUsed(currency);\n        }\n        return currency;\n    }\n\n    get lastCurrenciesUsed () {\n        if (!this._lastCurrenciesUsed) {\n            const currenciesRead = localStorage.getItem(CurrenciesStoreImpl.KEY_LAST);\n            if (currenciesRead) {\n                try {\n                    const parsed = JSON.parse(currenciesRead);\n                    this._lastCurrenciesUsed = [...parsed];\n                } catch (error) {\n                    console.warn(error);\n                    this._lastCurrenciesUsed = [];\n                }\n            } else {\n                this._lastCurrenciesUsed = [];\n            }\n        }\n        return this._lastCurrenciesUsed;\n    }\n\n    get lastCurrencyUsed () {\n        return this.lastCurrenciesUsed[0];\n    }\n\n    setLastCurrencyUsed (currency: string) {\n        this._lastCurrenciesUsed = [\n            currency, \n            ...this.lastCurrenciesUsed.filter(c=> c!==currency)];\n        localStorage.setItem(CurrenciesStoreImpl.KEY_LAST, \n            JSON.stringify(Array.from(this.lastCurrenciesUsed).slice(0, 5)));\n    }\n}\n"],"sourceRoot":""}