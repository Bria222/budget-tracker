{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","domain/utils/applyRate.ts","services/RemoteApi.ts","services/CurrenciesApi.ts","domain/stores/CurrenciesStoreImpl.ts"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","iter","Symbol","iterator","Object","prototype","toString","call","from","TypeError","applyRate","amount","rate","RemoteApi","baseUrl","this","path","queryParams","url","URL","keys","forEach","key","searchParams","append","request","fetch","response","ok","json","Error","status","params","getUrl","method","currenciesApi","primary","_backup","baseCurrency","backup","get","base","targetCurrencies","target","join","apikey","process","availableCurrencies","expectedCurrencyMatch","getRatesPrimary","resp","console","warn","getRatesBackup","rates","undefined","CurrenciesStoreImpl","importedCurrencies","currencies","_rates","_timestamps","_countriesCurrencyMap","_lastCurrenciesUsed","Map","entries","getTimestampsFromDisk","getRatesFromDisk","currencyTo","promise","shouldFetch","fetchRates","isPresent","currency","getRate","isTimestampUpdated","timestamp","Date","now","UPDATE_RATES_MS","getRates","olRates","saveTimestampsToDisk","saveRatesToDisk","toCurrency","isUpdated","ratesStr","localStorage","getItem","KEY","JSON","parse","timestampsStr","KEY_TS","setItem","stringify","countryCode","cs","default","setLastCurrencyUsed","lastCurrenciesUsed","filter","c","KEY_LAST","slice","currenciesRead","parsed","error"],"mappings":"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","file":"static/js/26.e1573132.chunk.js","sourcesContent":["import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","\nexport default function applyRate (amount: number, rate: number) {\n    return amount / rate;\n}\n","import { ObjectMap } from \"../api\";\n\nexport class RemoteApi {\n    readonly baseUrl: string;\n\n    constructor(baseUrl: string) {\n        this.baseUrl = baseUrl;\n    }\n\n    private getUrl (path: string, queryParams: ObjectMap<string>) {\n        const url = new URL(`${this.baseUrl}/${path}`);\n        Object\n            .keys(queryParams)\n            .forEach(\n                key => url.searchParams.append(key, queryParams[key]));\n        return url.toString();\n\n    }\n\n    private async fetch<T>(url: string, request?: RequestInit): Promise<T> {\n        const response = await fetch(url, request);\n        if (response.ok) {\n            return response.json();\n        }\n        throw new Error(`Error fetching ${url} > ${response.status}`);\n    }\n\n    async get<T>(path: string, params: ObjectMap<string>): Promise<T> {\n        const url = this.getUrl(path, params)\n        return this.fetch(url, {method: 'GET' });\n    }\n}","import { CurrencyRates } from \"../api\";\nimport { RemoteApi } from \"./RemoteApi\";\n\nclass CurrenciesApi {\n\n    private readonly primary: RemoteApi;\n    private _backup?: RemoteApi;\n\n    constructor () {\n        this.primary = new RemoteApi('https://api.currencystack.io');\n    }\n\n    // most likely it won't be instantiated, that's why it is lazy loaded\n    private get backup () {\n        if (this._backup === undefined) {\n            this._backup = new RemoteApi('https://api.exchangeratesapi.io');\n        }\n        return this._backup;\n    }\n\n    private async getRatesBackup (baseCurrency: string) {\n        return this.backup.get<CurrencyRates>('latest', {base: baseCurrency});\n    }\n\n    private async getRatesPrimary (baseCurrency: string, targetCurrencies: Iterable<string>) {\n        return this.primary.get<CurrencyRates>('currency', \n            {\n                base: baseCurrency,\n                target: Array.from(targetCurrencies).join(','),\n                apikey: process.env.REACT_APP_CURRENCY_API_KEY || ''\n            });\n    }\n    \n    async getRates(baseCurrency: string, availableCurrencies: Iterable<string>, expectedCurrencyMatch?: string) {\n        let resp;\n        try {\n            resp = await this.getRatesPrimary(baseCurrency, availableCurrencies);\n        } catch (error) {\n            console.warn('Trying to fetch backup API: ', error);\n            resp = await this.getRatesBackup(baseCurrency);\n        } finally {\n            if (!resp) {\n                throw new Error(`There is no response for ${baseCurrency}`);\n            }\n            if (expectedCurrencyMatch && resp && !(expectedCurrencyMatch in resp.rates)) {\n                throw new Error(`There is no match for ${baseCurrency} => ${expectedCurrencyMatch}`);\n            }\n            if (Object.keys(resp.rates).length <= 0) {\n                throw new Error(`Empty response for ${baseCurrency}`);\n            }\n            return resp;\n        }\n    }\n}\n\nexport const currenciesApi = new CurrenciesApi();\n","import { CurrencyRates, ObjectMap } from \"../../api\";\nimport { currenciesApi } from \"../../services/CurrenciesApi\";\nimport { CurrenciesStore } from \"./interfaces\";\nimport applyRate from \"../utils/applyRate\";\n\nexport class CurrenciesStoreImpl implements CurrenciesStore {\n    static readonly KEY = 'currencyRates';\n    static readonly KEY_TS = 'currencyTimestamps';\n    static readonly KEY_LAST = 'lastCurrencies';\n    static readonly UPDATE_RATES_MS = 12 * 3600 * 1000;\n    \n    readonly currencies: Map<string, string>;\n    private _rates: ObjectMap<CurrencyRates>;\n    private _timestamps: ObjectMap<number>;\n    private _countriesCurrencyMap?: ObjectMap<string>;\n    private _lastCurrenciesUsed?: string[];\n\n    constructor(importedCurrencies: ObjectMap<string>) {\n        this.currencies = new Map(Object.entries(importedCurrencies));\n        this._timestamps = this.getTimestampsFromDisk();\n        this._rates = this.getRatesFromDisk();\n    }\n\n    /** \n     * @returns Currency exchange rate\n     * @throws Error when there is no rate for that pair of currencies\n     */\n    async getRate(baseCurrency: string, currencyTo: string): Promise<number> {\n        let promise = undefined;\n        if (this.shouldFetch(baseCurrency, currencyTo)) {\n            promise = this.fetchRates(baseCurrency, currencyTo);\n        }\n        if (promise && !this.isPresent(baseCurrency, currencyTo)) {\n            try {\n                await promise;\n            } catch (error) {\n                console.warn(error);\n            }\n        }\n        return this._rates[baseCurrency].rates[currencyTo];\n    }\n\n    getLocalRates(baseCurrency: string) {\n        return this._rates && this._rates[baseCurrency];\n    }\n\n    /** \n     * @returns Currency exchange rates for a base currency\n     */\n    async getRates(baseCurrency: string): Promise<CurrencyRates> {\n        let promise = undefined;\n        if (this.shouldFetch(baseCurrency)) {\n            promise = this.fetchRates(baseCurrency);\n        }\n        if (promise) {\n            try {\n                await promise;\n            } catch (error) {\n                console.warn(error);\n            }\n        }\n        return this._rates[baseCurrency];\n    }\n\n    /** \n     * @returns amount in base currency. \\ \n     * If baseCurrency == currency it returns the same input @param amount.\n     * It returns undefined if cannot get currency rate.\n     * @throws Error when there is no rate for that pair of currencies\n     */\n    async getAmountInBaseCurrency (baseCurrency: string, currency: string, amount: number) {\n        if (baseCurrency && currency !== baseCurrency) {\n            const rate = await this.getRate(baseCurrency, currency);\n            return applyRate(amount, rate);\n        }\n        return amount;\n    }\n\n    private isUpdated(baseCurrency: string) {\n        return baseCurrency in this._timestamps \n            && this.isTimestampUpdated(this._timestamps[baseCurrency]);\n    }\n\n    private isTimestampUpdated(timestamp: number) {\n        return Date.now() - timestamp <= CurrenciesStoreImpl.UPDATE_RATES_MS;\n    }\n\n    /** \n     * @throws Error when it returns invalid response after fetching currencies  \n     */\n    private async fetchRates(baseCurrency: string, expectedCurrencyMatch?: string) {\n        const rates = await currenciesApi.getRates(\n            baseCurrency, \n            this.currencies.keys(),\n            expectedCurrencyMatch);\n        if (Object.keys(rates.rates).length > 0) {\n            const olRates = this._rates[baseCurrency] || {};\n            this._rates[baseCurrency] = {...olRates, ...rates};\n            this._timestamps[baseCurrency] = Date.now()\n            this.saveTimestampsToDisk();\n            this.saveRatesToDisk();\n        }\n    }\n\n    private shouldFetch (baseCurrency: string, toCurrency?: string) {\n        return this._rates === undefined || \n            !(baseCurrency in this._rates) || \n            !this.isUpdated(baseCurrency) ||\n            (toCurrency && !this.isPresent(baseCurrency, toCurrency));\n    }\n\n    private isPresent(baseCurrency: string, toCurrency: string){\n        return this._rates && \n            baseCurrency in this._rates && \n            toCurrency in this._rates[baseCurrency].rates;\n    }\n\n    private getRatesFromDisk () {\n        const ratesStr = localStorage.getItem(CurrenciesStoreImpl.KEY);\n        if (ratesStr && ratesStr.length > 0) {\n            return JSON.parse(ratesStr);\n        }\n        return {};\n    }\n\n    private getTimestampsFromDisk () {\n        const timestampsStr = localStorage.getItem(CurrenciesStoreImpl.KEY_TS);\n        if (timestampsStr && timestampsStr.length > 0) {\n            return JSON.parse(timestampsStr);\n        }\n        return {};\n    }\n\n    private saveRatesToDisk () {\n        localStorage.setItem(CurrenciesStoreImpl.KEY, JSON.stringify(this._rates));\n    }\n\n    private saveTimestampsToDisk () {\n        localStorage.setItem(CurrenciesStoreImpl.KEY_TS, JSON.stringify(this._timestamps));\n    }\n\n    async getFromCountry (countryCode: string) {\n        if (!this._countriesCurrencyMap) {\n            const cs = await import('../../constants/countryCurrency.json');\n            this._countriesCurrencyMap = cs.default;    \n        }\n        const currency = this._countriesCurrencyMap[countryCode];\n        if (currency) {\n            this.setLastCurrencyUsed(currency);\n        }\n        return currency;\n    }\n\n    get lastCurrenciesUsed () {\n        if (!this._lastCurrenciesUsed) {\n            const currenciesRead = localStorage.getItem(CurrenciesStoreImpl.KEY_LAST);\n            if (currenciesRead) {\n                try {\n                    const parsed = JSON.parse(currenciesRead);\n                    this._lastCurrenciesUsed = [...parsed];\n                } catch (error) {\n                    console.warn(error);\n                    this._lastCurrenciesUsed = [];\n                }\n            } else {\n                this._lastCurrenciesUsed = [];\n            }\n        }\n        return this._lastCurrenciesUsed;\n    }\n\n    get lastCurrencyUsed () {\n        return this.lastCurrenciesUsed[0];\n    }\n\n    setLastCurrencyUsed (currency: string) {\n        this._lastCurrenciesUsed = [\n            currency, \n            ...this.lastCurrenciesUsed.filter(c=> c!==currency)];\n        localStorage.setItem(CurrenciesStoreImpl.KEY_LAST, \n            JSON.stringify(Array.from(this.lastCurrenciesUsed).slice(0, 5)));\n    }\n}\n"],"sourceRoot":""}